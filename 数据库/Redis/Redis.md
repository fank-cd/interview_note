# Redis
Redis 中常见类型的底层数据结构
Redis 所有的数据结构都是以唯一的 key 字符串作为名称，然后通过这个唯一 key 值来获取相应的 value 数据。不同类型的数据结构的差异就在于 value 的结构不一样。


  * string (字符串)：Redis 的字符串是动态字符串，是可以修改的字符串，内部结构实现上类似于 Java 的 ArrayList，采用预分配冗余空间的方式来减少内存的频繁分配
    * 常见用途：
      * 用途示例：将用户信息结构体使用 JSON 序列化成字符串，然后将序列化后的字符串塞进 Redis 来缓存
  * list (列表)：Redis 的列表相当于 Java 语言里面的 LinkedList，注意它是链表而不是数组
    * 操作时间
      * 插入删除：O(1)
      * 索引 O(n)
    * 用途示例：
      * 异步队列：将需要延后处理的任务结构体序列化成字符串塞进 Redis 的列表，另一个线程从这个列表中轮询数据进行处理。
    * 底层实现：
      * 用 ziplist（数据较少的时候），加上prev，next指针，Redis 将链表和 ziplist 结合起来组成了 quicklist。也就是将多个 ziplist 使用双向指针串起来使用
      * ziplist，也即是压缩列表。它将所有的元素紧挨着一起存储，分配的是一块连续的内存
      * 为什么这样设计：普通的链表需要的附加指针空间太大，会比较浪费空间，而且会加重内存的碎片化
      * 好处：满足了快速的插入删除性能，又不会出现太大的空间冗余
  * hash (字典)：Redis 的字典相当于 Java 语言里面的 HashMap，它是无序字典。
    * Redis 的字典的值只能是字符串
    * 内部实现：数组 + 链表二维结构。第一维 hash 的数组位置碰撞时，就会将碰撞的元素使用链表串接起来。
    * Rehash策略：渐进式 rehash
      * 渐进式 rehash：在 rehash 的同时，保留新旧两个 hash 结构，查询时会同时查询两个 hash 结构，然后在后续的定时任务中以及 hash 操作指令中，循序渐进地将旧 hash 的内容一点点迁移到新的 hash 结构中。当搬迁完成了，就会使用新的hash结构取而代之。当 hash 移除了最后一个元素之后，该数据结构自动被删除，内存被回收。
    * 缺点：hash 结构的存储消耗要高于单个字符串，
    * 优点：相比于字符串，不需要全部序列化整个对象，hash 可以对结构中的每个字段单独存储，




  * set (集合)：Redis 的集合相当于 Java 语言里面的 HashSet，它内部的键值对是无序的唯一的。它的内部实现相当于一个特殊的字典，字典中所有的 value 都是一个值NULL
    * 特点：
      * 无序
      * 唯一
      * 相当于没有值的字典
    * 用途示例：存储活动中奖的用户 ID




  * zset (有序集合)：类似于 Java 的 SortedSet 和 HashMap 的结合体，一方面它是一个 set，保证了内部 value 的唯一性，另一方面它可以给每个 value 赋予一个 score，代表这个 value 的排序权重
    * 内部实现：跳表
    * 用途示例：存储学生的成绩，value 值是学生的 ID，score 是他的考试成绩。我们可以对成绩按分数进行排序就可以得到他的名次




  * 容器型数据结构的通用规则
    * create if not exists
    * drop if no elements
  * 过期时间：
    * Redis 所有的数据结构都可以设置过期时间，时间到了，Redis 会自动删除相应的对象。
    * 过期的单位：单位。比如一个 hash 结构的过期是整个 hash 对象的过期，而不是其中的某个子 key。
    * tips：如果一个字符串已经设置了过期时间，然后你调用了 set 方法修改了它，它的过期时间会消失。






 Redis 的哨兵机制
在 Redis 中，实现 高可用 的技术主要包括 持久化、复制、哨兵 和 集群，下面简单说明它们的作用，以及解决了什么样的问题：
  * 持久化：持久化是 最简单的 高可用方法。它的主要作用是 数据备份，即将数据存储在 硬盘，保证数据不会因进程退出而丢失。
  * 复制：复制是高可用 Redis 的基础，哨兵 和 集群 都是在 复制基础 上实现高可用的。复制主要实现了数据的多机备份以及对于读操作的负载均衡和简单的故障恢复。缺陷是故障恢复无法自动化、写操作无法负载均衡、存储能力受到单机的限制。
  * 哨兵：在复制的基础上，哨兵实现了 自动化 的 故障恢复。缺陷是 写操作 无法 负载均衡，存储能力 受到 单机 的限制。
  * 集群：通过集群，Redis 解决了 写操作 无法 负载均衡 以及 存储能力 受到 单机限制 的问题，实现了较为 完善 的 高可用方案。






Redis主从复制的问题
  1. 一旦 主节点宕机，从节点 作为 主节点 的 备份 可以随时顶上来。
  2. 扩展 主节点 的 读能力，分担主节点读压力。




主从复制 同时存在以下几个问题：
  1.  一旦 主节点宕机，从节点 晋升成 主节点，同时需要修改 应用方 的 主节点地址，还需要命令所有 从节点 去 复制 新的主节点，整个过程需要 人工干预。
  2. 主节点 的 写能力 受到 单机的限制。
  3. 主节点 的 存储能力 受到 单机的限制。
  4.  原生复制 的弊端在早期的版本中也会比较突出，比如：Redis 复制中断 后，从节点 会发起 psync。此时如果 同步不成功，则会进行 全量同步，主库 执行 全量备份 的同时，可能会造成毫秒或秒级的 卡顿。


基本工作原理：
我们可以将 Redis Sentinel 集群看成是一个 ZooKeeper 集群，它是集群高可用的心脏，它一般是由 3～5 个节点组成，这样挂了个别节点集群还可以正常运转。它负责持续监控主从节点的健康，当主节点挂掉时，自动选择一个最优的从节点切换为主节点。客户端来连接集群时，会首先连接 sentinel，通过 sentinel 来查询主节点的地址，然后再去连接主节点进行数据交互。当主节点发生故障时，客户端会重新向 sentinel 要地址，sentinel 会将最新的主节点地址告诉客户端。如此应用程序将无需重启即可自动完成节点切换。


Sentinel 的主要功能包括 主节点存活检测、主从运行情况检测、自动故障转移 （failover）、主从切换。Redis 的 Sentinel 最小配置是一主一从。
  * 监控:Sentinel 会不断的检查 主服务器 和 从服务器 是否正常运行。
  * 通知:当被监控的某个 Redis 服务器出现问题，Sentinel 通过 API 脚本 向 管理员 或者其他的 应用程序 发送通知。
  * 自动故障转移当 主节点 不能正常工作时，Sentinel 会开始一次 自动的 故障转移操作，它会将与 失效主节点 是 主从关系 的其中一个 从节点 升级为新的 主节点，并且将其他的 从节点 指向 新的主节点。
  * 配置提供者:在 Redis Sentinel 模式下，客户端应用 在初始化时连接的是 Sentinel 节点集合，从中获取 主节点 的信息。


主观下线和客观下线
默认情况下，每个 Sentinel 节点会以 每秒一次 的频率对 Redis 节点和 其它 的 Sentinel 节点发送 PING 命令，并通过节点的 回复 来判断节点是否在线。
  * 主观下线: 适用于所有 主节点 和 从节点。如果在 down-after-milliseconds 毫秒内，Sentinel 没有收到 目标节点 的有效回复，则会判定 该节点 为 主观下线。
  * 客观下线:只适用于 主节点。如果 主节点 出现故障，Sentinel 节点会通过 sentinel is-master-down-by-addr 命令，向其它 Sentinel 节点询问对该节点的 状态判断。如果超过 <quorum> 个数的节点判定 主节点 不可达，则该 Sentinel 节点会判断 主节点 为 客观下线。




Sentinel的通信命令
  * 连接其他哨兵：pub/sub
  * 连接redis：cmd


工作流程：
每个 Sentinel 节点都需要 定期执行 以下任务：
  1. 每个 Sentinel 以 每秒钟 一次的频率，向它所知的 主服务器、从服务器 以及其他 Sentinel 实例 发送一个 PING 命令。
  2. 如果一个 实例（instance）距离 最后一次 有效回复 PING 命令的时间超过 down-after-milliseconds 所指定的值，那么这个实例会被 Sentinel 标记为 主观下线。
  3. 如果一个 主服务器 被标记为 主观下线，那么正在 监视 这个 主服务器 的所有 Sentinel 节点，要以 每秒一次 的频率确认 主服务器 的确进入了 主观下线 状态。
  4. 如果一个 主服务器 被标记为 主观下线，并且有 足够数量 的 Sentinel（至少要达到 配置文件 指定的数量）在指定的 时间范围 内同意这一判断，那么这个 主服务器 被标记为 客观下线。
  5. 在一般情况下， 每个 Sentinel 会以每 10 秒一次的频率，向它已知的所有 主服务器 和 从服务器 发送 INFO 命令。当一个 主服务器 被 Sentinel 标记为 客观下线 时，Sentinel 向 下线主服务器 的所有 从服务器 发送 INFO 命令的频率，会从 10 秒一次改为 每秒一次。
  6. Sentinel 和其他 Sentinel 协商 主节点 的状态，如果 主节点 处于 SDOWN 状态，则投票自动选出新的 主节点。将剩余的 从节点 指向 新的主节点 进行 数据复制。
  7. 当没有足够数量的 Sentinel 同意 主服务器 下线时， 主服务器 的 客观下线状态 就会被移除。当 主服务器 重新向 Sentinel 的 PING 命令返回 有效回复 时，主服务器 的 主观下线状态 就会被移除。




消息丢失：
Redis 主从采用异步复制，意味着当主节点挂掉时，从节点可能没有收到全部的同步消息，这部分未同步的消息就丢失了。如果主从延迟特别大，那么丢失的数据就可能会特别多。Sentinel 无法保证消息完全不丢失，但是也尽可能保证消息少丢失。它有两个选项可以限制主从延迟过大。
```
min-slaves-to-write 1
min-slaves-max-lag 10
```
第一个参数表示主节点必须至少有一个从节点在进行正常复制，否则就停止对外写服务，丧失可用性。
何为正常复制，何为异常复制？这个就是由第二个参数控制的，它的单位是秒，表示如果 10s 没有收到从节点的反馈，就意味着从节点同步不正常，要么网络断开了，要么一直没有给反馈。






Redis 实现分布式锁
Redis 锁主要利用 Redis 的 setnx 命令。
  * 加锁命令：SETNX key value，当键不存在时，对键进行设置操作并返回成功，否则返回失败。KEY 是锁的唯一标识，一般按业务来决定命名。
  * 解锁命令：DEL key，通过删除键值对释放锁，以便其他线程可以通过 SETNX 命令来获取锁。
  * 锁超时：EXPIRE key timeout, 设置 key 的超时时间，以保证即使锁没有被显式释放，锁也可以在一定时间后自动释放，避免资源被永远锁住。


伪代码如下：
```
if (setnx(key, 1) == 1){
    expire(key, 30)
    try {
        //TODO 业务逻辑
    } finally {
        del(key)
    }
}
```


上面的方法存在一些问题，比如
  1. SETNX 和 EXPIRE 非原子性：如果 SETNX 成功，在设置锁超时时间后，服务器挂掉、重启或网络问题等，导致 EXPIRE 命令没有执行，锁没有设置超时时间变成死锁。
    * 解决办法：
      *  Redis 2.6.12以上版本为set指令增加了可选参数，伪代码如下：set（key，1，30，NX）
      * Lua脚本
  2. 锁误解除：如果线程 A 成功获取到了锁，并且设置了过期时间 30 秒，但线程 A 执行时间超过了 30 秒，锁过期自动释放，此时线程 B 获取到了锁；随后 A 执行完成，线程 A 使用 DEL 命令来释放锁，但此时线程 B 加的锁还没有执行完成，线程 A 实际释放的线程 B 加的锁。
    * 解决办法
      * 通过在 value 中设置当前线程加锁的标识，在删除之前验证 key 对应的 value 判断锁是否是当前线程持有。可生成一个 UUID 标识当前线程、因为判断和释放锁是两个独立操作，不是原子性。所以这块使用lua脚本
      * 使用 lua 脚本做验证标识和解锁操作。
  3. 超时解锁导致并发：如果线程 A 成功获取锁并设置过期时间 30 秒，但线程 A 执行时间超过了 30 秒，锁过期自动释放，此时线程 B 获取到了锁，线程 A 和线程 B 并发执行。
    * 解决办法：
      * 将过期时间设置足够长，确保代码逻辑在锁释放之前能够执行完成。
      * 为获取锁的线程增加守护线程，为将要过期但未释放的锁增加有效时间。
  4. 不可重入：当线程在持有锁的情况下再次请求加锁，如果一个锁支持一个线程多次加锁，那么这个锁就是可重入的。如果一个不可重入锁被再次加锁，由于该锁已经被持有，再次加锁会失败
    * 解决办法：
      * Redis 可通过对锁进行重入计数，加锁时加 1，解锁时减 1，当计数归 0 时释放锁。在本地记录记录重入次数
  5. 无法等待锁释放：上述命令执行都是立即返回的，如果客户端可以等待锁释放就无法使用。
    * 解决办法：
      * *可以通过客户端轮询的方式解决该问题，当未获取到锁时，等待一段时间重新获取锁，直到成功获取锁或等待超时。这种方式比较消耗服务器资源，当并发量比较大时，会影响服务器的效率。
      * 另一种方式是使用 Redis 的发布订阅功能，当获取锁失败时，订阅锁释放消息，获取锁成功后释放时，发送锁释放消息














 Redis 持久化中 rdb 以及 aof
  * RDB：快照形式是直接把内存中的数据保存到一个 dump 文件中，定时保存，保存策略。Redis默认是快照RDB的持久化方式
  * AOF：把所有的对Redis的服务器进行修改的命令都存到一个文件里，命令的集合。、
  * 当 Redis 重启时，它会优先使用 AOF 文件来还原数据集，因为 AOF 文件保存的数据集通常比 RDB 文件所保存的数据集更完整。




RDB持久化：
  * 工作原理：当 Redis 需要做持久化时，Redis 会 fork 一个子进程，子进程将数据写到磁盘上一个临时 RDB 文件中。当子进程完成写临时文件后，将原来的 RDB 替换掉，这样的好处就是可以 copy-on-write。
  * Redis.conf配置

```
save 900 1 # 900秒之内，如果超过1个key被修改，则发起快照保存
save 300 10 # 300秒内，如果超过10个key被修改，则发起快照保存
save 60 10000 # 1分钟之内，如果1万个key被修改，则发起快照保存
```
  * 优点：
    * 这种文件非常适合用于进行备份： 比如说，你可以在最近的 24 小时内，每小时备份一次 RDB 文件，并且在每个月的每一天，也备份一个 RDB 文件。 这样的话，即使遇上问题，也可以随时将数据集还原到不同的版本。RDB 非常适用于灾难恢复（disaster recovery）。
    * 灵活设置备份的频率和周期
    * 性能最大化：对于 Redis 的服务进程而言，在开始持久化时，它唯一需要做的只是 fork 出子进程，之后再由子进程完成这些持久化的工作，这样就可以极大的避免服务进程执行 IO 操作了。也就是说，RDB 对 Redis 对外提供的读写服务，影响非常小，可以让 Redis 保持高性能
    * 恢复更快速：相比于 AOF 机制，RDB 的恢复速度更更快，更适合恢复数据，特别是在数据集非常大的情况。
  * 缺点：
    * 如果你需要尽量避免在服务器故障时丢失数据，那么 RDB 不适合你。 虽然 Redis 允许你设置不同的保存点（save point）来控制保存 RDB 文件的频率， 但是， 因为RDB 文件需要保存整个数据集的状态， 所以它并不是一个轻松的操作。 因此你可能会至少 5 分钟才保存一次 RDB 文件。 在这种情况下， 一旦发生故障停机， 你就可能会丢失好几分钟的数据。
    * RDB备份机制，是通过一个fork子进程来进行协助数据的持久化，在持久化的过程中，将会暂停所有的redis的数据集的操作，如果redis的数据集庞大，那么将有可能导致redis停止对外服务几百毫秒，或者是1秒




AOF 持久化：
  * 工作原理：使用 AOF 做持久化，每一个写命令都通过write函数追加到 appendonly.aof 中
  * Redis.conf配置

```
appendfsync yes
appendfsync always     #每次有数据修改发生时都会写入AOF文件。
appendfsync everysec   #每秒钟同步一次，该策略为AOF的缺省策略。
```
  * 优点：
    * 使用 AOF 持久化会让 Redis 变得非常耐久（much more durable）：你可以设置不同的 fsync 策略，比如无 fsync ，每秒钟一次 fsync ，或者每次执行写入命令时 fsync 。 AOF 的默认策略为每秒钟 fsync 一次，在这种配置下，Redis 仍然可以保持良好的性能，并且就算发生故障停机，也最多只会丢失一秒钟的数据（ fsync 会在后台线程执行，所以主线程可以继续努力地处理命令请求）。
    * AOF是基于日志模式记录数据操作，所以该操作可以更加好的保证数据的安全性。
    * AOF日志写入记录操作模式为 append 模式，所以在使用过程中，即使服务器出现的宕机情况，也不会破坏redis 的日志文件内容。
    * AOF 包含一个格式清晰、易于理解的日志文件用于记录所有的修改操作
  * 缺点：
    * 对于相同的数据集来说，AOF 文件的体积通常要大于 RDB 文件的体积。根据所使用的 fsync 策略，AOF 的速度可能会慢于 RDB。 在一般情况下， 每秒 fsync 的性能依然非常高， 而关闭 fsync 可以让 AOF 的速度和 RDB 一样快， 即使在高负荷之下也是如此。 不过在处理巨大的写入载入时，RDB 可以提供更有保证的最大延迟时间（latency）
    * 针对相同数据量大小的恢复数据操作，建议使用RDB恢复，因相同数据大小情况下，RDB恢复速度比AOF恢复更快。
    * 根据同步策略的不同，AOF 在运行效率上往往会慢于 RDB 。总之，每秒同步策略的效率是比较高的，同步禁用策略的效率和 RDB 一样高效。




两者的区别：
  * RDB持久化是指在指定的时间间隔内将内存中的数据集快照写入磁盘，实际操作过程是fork一个子进程，先将数据集写入临时文件，写入成功后，再替换之前的文件，用二进制压缩存储。
  * AOF持久化以日志的形式记录服务器所处理的每一个写、删除操作，查询操作不会记录，以文本的方式记录，可以打开文件看到详细的操作记录。




Redis 为什么在使用 RDB 进行快照时会通过子进程的方式进行实现？
  1. 通过 fork 创建的子进程能够获得和父进程完全相同的内存空间，父进程对内存的修改对于子进程是不可见的，两者不会相互影响；
  2. 通过 fork 创建子进程时不会立刻触发大量内存的拷贝，内存在被修改时会以页为单位进行拷贝，这也就避免了大量拷贝内存而带来的性能问题；






 缓存雪崩和缓存击穿
  * 缓存穿透：缓存穿透是指大量请求都查询数据库中不存在的数据，缓存和数据都查询不到数据，这使得请求每次都打到数据库上。缓存穿透往往是来自于故意攻击。
    * 解决方案：
      * 业务层数据校验：可以对请求数据进行校验，比如对于id<0的直接返回错误
      * 缓存空数据：将相应的key在redis中设置对应value为null（或者其它能反馈错误的值），这样请求到来时缓存一样可以生效。（此时可以将空对象的过期时间设置较短，否则攻击者请求大量数据库中不存在id，同样会缓存多个null值，也会带来redis使用内存剧增的问题）
      * 使用布隆过滤器：
        * 布隆过滤器：位数组、
          * 当一个元素加入过滤器时，使用多个hash函数对元素求值，并将位数组中对应位置为1；
          * 判断一个元素是否在过滤器中时，使用多个函数对元素求值，并判断位数组对应位置是否为1。如果都为1，认为元素在过滤器中；否则认为元素不在过滤器中。
  * 缓存击穿：redis缓存中有一个key是大量请求同时访问的热点数据，如果突然这个key时间到了，那么大量的请求在缓存中获取不到该key，穿过缓存直接来到数据库导致数据库崩溃，这样因为单个key失效而穿过缓存到数据库称为缓存击穿
    * 解决方案：
      * 使用互斥锁：当缓存失效时，引入一个锁，获得锁的线程去请求数据库，更新缓存，其余线程阻塞等待。
        * 设置锁过期时间，防止死锁
        * 为锁设置一个随机值，相同则删除锁，为了防止请求更新缓存的时间比锁的有效期还要长，导致在缓存更新过程中锁就失效了
      * 永远不过期：不设置过期时间
        * 从缓存层面来看，确实没有设置过期时间，所以不会出现热点 key 过期后产生的问题，也就是“物理”不过期。
        * 从功能层面来看，为每个 value 设置一个逻辑过期时间，当发现超过逻辑过期时间后，会使用单独的线程去构建缓存。
        * 不足：会出现数据不一致的情况，这取决于应用方是否容忍这种不一致
  * 缓存雪崩：类似缓存击穿，区别在于多条数据同时在某一时间过期
    * 解决方案：
      * 随机化过期时间：为了避免缓存同时过期，可在设置缓存时添加随机时间，这样就可以极大的避免大量的缓存同时失效。
      * 二级缓存指的是除了 Redis 本身的缓存，再设置一层缓存，当 Redis 失效之后，先去查询二级缓存。
      * 缓存预热：对于即将来临的大量请求，我们可以提前走一遍系统，将数据提前缓存在Redis中，并设置不同的过期时间。
      * 保证Redis服务高可用：主从、哨兵、集群


伪代码：
```
public String get(key) {
      String value = redis.get(key);
      if (value == null) { //代表缓存值过期
          //设置3min的超时，防止del操作失败的时候，下次缓存过期一直不能load db
          // 使用setnx实现锁的效果
          if (redis.setnx(key_mutex, 1, 3 * 60) == 1) {  //代表设置成功
               // 这时候只允许一个线程去load db
               value = db.get(key);
               redis.set(key, value, expire_secs);
               redis.del(key_mutex);
          } else {  //这个时候代表同时候的其他线程已经load db并回设到缓存了，这时候重试获取缓存值即可
               sleep(50);
               get(key);  //重试
          }
       } else {
         return value;
       }
}
```




Redis 中跳表的应用以及优缺点
  * 注意：只能用于元素有序的情况
  * 跳表(skip  list)对标的是平衡树和二分查找，是一种插入/删除/搜索都是O(logn)的数据结构。
  * 最大优势是原理简单，容易实现，方便扩展，效率更高。因此在一些热门的项目里用来替代平衡树,如Redis，LevelDb等。
  * 空间复杂度 O(n)
  * 应用：Redis Zset
  * 优点：
    * 对于单向链表，只能从头到尾遍历，时间复杂度为O(n)
    * 对于数组，删除插入复杂度太高O(n)，还会涉及数组的扩容操作
    * 平衡二叉树查询速度很快，但是需要平衡的操作开销很大
    * 红黑树的话，性能差不多，但是如果需要多进程同时访问修改的话，红黑树有个平衡的过程，争锁代价也比较大
    * 跳表的线程安全也是通过cas锁实现的，跳表的构建相对简单，同时支持范围查找
  * 缺点：
相对于红黑树，空间消耗增加

操作| 时间复杂度
---|---
preappend| O(logn)
append| O(logn)
lookup| O(logn)
insert| O(logn)
delete| O(logn)



---
### NOTE ATTRIBUTES
>Created Date: 2021-03-12 16:41:18
>Last Evernote Update Date: 2021-03-21 17:32:48
>author: 一的平方
>source: desktop.win
>source-application: yinxiang.win32
# 互斥锁和自旋锁
  * 互斥锁 ：
    * 用于保护临界区，确保同一时间只有一个线程访问数据。对共享资源的访问，先对互斥量进行加锁，如果互斥量已经上锁，调用线程会阻塞，直到互斥量被解锁。在完成了对共享资源的访问后，要对互斥量进行解锁
    * 加锁失败：
      * 线程会释放 CPU ，给其他线程
      * 由加锁失败而导致的阻塞是由操作系统内核实现的，此时会用户态陷入到内核态
      * 开销成本（两次线程上下文切换的成本）：
        * 当线程加锁失败时，内核会把线程的状态从「运行」状态设置为「睡眠」状态，然后把 CPU 切换给其他线程运行；
        * 当锁被释放时，之前「睡眠」状态的线程会变为「就绪」状态，然后内核会在合适的时间，把 CPU 切换给该线程运行
    * 使用场景：
      * 1.线程等待锁的时间较长
      * 2.单核处理器
      * 3.临界区有IO操作
      * 4.临界区操作复杂或者有大量循环
      * 5.临界区竞争非常激烈
  * 自旋锁：
    * 与互斥锁类似类似，仍然保证同一时间只有一个线程访问数据。但实现不同，在获取锁之前一直处于忙等(自旋)阻塞状态
    * 加锁失败：
      * 线程会忙等待，直到它拿到锁
      * 在「用户态」完成加锁和解锁操作，不会陷入内核态
    * 实现：
      * 通过 CPU 提供的 CAS 函数（Compare And Swap）
        * 第一步，查看锁的状态，如果锁是空闲的，则执行第二步；
        * 第二步，将锁设置为当前线程持有
        * CAS将上述操作合并成一条硬件级指令，形成原子指令
    * 使用场景：
      * 1.线程等待锁的时间短
      * 2.加锁的代码（临界区）频繁被访问，竞争不激烈
      * 3.cpu资源不紧张
      * 4.多核处理器
  * 区别：
    * 申请自旋锁的时候，线程不会被挂起，而是处于忙等的状态
    * 申请互斥锁失败的时候，线程会被挂起，将cpu让给其他线程
  * 临界区：每个进程中访问临界资源的那段程序称为临界区，每次只允许一个进程进入临界区，进入后不允许其他进程进入。










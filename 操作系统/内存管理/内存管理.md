# 内存管理
虚拟地址与物理地址映射


虚拟内存地址：程序所使用的内存地址叫做
物理内存地址：实际存在硬件里面的空间地址


  * 物理内存：
    * 早期的cpu是直接操作物理内存的
    * 带来的问题：
      * 程序运行的地址不确定：每次编译时不能确定该内存地址是否被占用
      * 进程地址空间不隔离：程序间可以互相访问对方内存空间，极不安全
      * 内存使用效率低：程序整块加载进内存，带来的内存碎片问题会导致使用效率低
  * 分段：程序是由若干个逻辑分段组成的，如可由代码分段、数据分段、栈段、堆段组成。不同的段是有不同的属性的，所以就用分段（Segmentation）的形式把这些段分离出来
    * 在32位操作系统中，系统会该进程分配一个4GB大小的虚拟进程地址空间
    * 分段机制下虚拟地址映射至物理地址：通过段内偏移量+段选择子找到映射的物理地址
      * 段内偏移量：位于 0 和段界限之间，如果段内偏移量是合法的，就将段基地址加上段内偏移量得到物理内存地址
      * 段选择子
        * 段号：段表的索引
        * 寄存器保存段选择子
        * 段表
          * 段的基地址
          * 段的界限和特权等级等
    * 分段机制会把程序的虚拟地址分成 5 个段，每个段在段表中有一个项，在这一项找到段的基地址，再加上偏移量，于是就能找到物理内存中的地址
      * 代码段：代码段是用来存放可执行文件的操作指令，也就是说是它是可执行程序在内存中的镜像。代码段需要防止在运行时被非法修改，所以只准许读取操作，而不允许写入（修改）操作——它是不可写的。
      * 数据段：数据段用来存放可执行文件中已初始化全局变量，换句话说就是存放程序静态分配[1]的变量和全局变量。
      * BSS段：BSS段包含了程序中未初始化的全局变量，在内存中 bss段全部置零。
      * 堆（heap）：堆是用于存放进程运行中被动态分配的内存段，它的大小并不固定，可动态扩张或缩减。当进程调用malloc等函数分配内存时，新分配的内存就被动态添加到堆上（堆被扩张）；当利用free等函数释放内存时，被释放的内存从堆中被剔除（堆被缩减）
      * 栈：栈是用户存放程序临时创建的局部变量，也就是说我们函数括弧“{}”中定义的变量（但不包括static声明的变量，static意味着在数据段中存放变量）。除此以外，在函数被调用时，其参数也会被压入发起调用的进程栈中，并且待到调用结束后，函数的返回值也会被存放回栈中。由于栈的先进先出特点，所以栈特别方便用来保存/恢复调用现场。从这个意义上讲，我们可以把堆栈看成一个寄存、交换临时数据的内存区。
    * 段内空间连续，段与段之间不连续
    * 解决的问题：
      * 程序运行的地址不确定
      * 地址空间不隔离
    * 未解决的问题：
      * 内存碎片的问题。
      * 内存交换的效率低
  * 分页：分页是把整个虚拟和物理内存空间切成一段段固定尺寸的大小。这样一个连续并且尺寸固定的内存空间，我们叫页（Page）。在 Linux 下，每一页的大小为 4KB。
    * 虚拟地址与物理地址之间通过页表来映射
      * 页表实际上存储在 CPU 的内存管理单元 （MMU）中
    * 分页的方式使得我们在加载程序的时候，不再需要一次性都把程序加载到物理内存中。我们完全可以在进行虚拟内存和物理内存的页之间的映射之后，并不真的把页加载到物理内存里，而是只有在程序运行中，需要用到对应虚拟内存页里面的指令和数据时，再加载到物理内存里面去。
    * 与分段的区别：粒度更小、大小固定
    * 分页如何映射：
      * 虚拟地址分为两部分，页号和页内偏移
        * 页号作为页表的索引
        * 页表包含物理页每页所在物理内存的基地址
        * 基地址与页内偏移的组合就形成了物理内存地址
    * 解决的问题：
      * 解决了在分段式内存管理中内存碎片与内存交换效率低的问题
      * 内存碎片:
        * 由于内存空间都是预先划分好的，也就不会像分段会产生间隙非常小的内存。而采用了分页，那么释放的内存都是以页为单位释放的，也就不会产生无法给进程使用的小内存。(每页大小固定的）
        * 内存交换效率低：以页为单位进行内存交换，一次性写入磁盘的也只有少数的一个页或者几个页，不会花太多时间，内存交换的效率就相对比较高
    * 存在的问题：
      * 简单的分页机制会带来空间的问题
        * 太多的进程会带来过多的页表，假如100个进程，需要400MB内存来存储
        * 如何解决：
          * 多级页表
            * 多级页表的问题：
              * 导致 CPU 在寻址的过程中，需要有很多层表参与，加大了时间上的开销。
                * 根据程序的局部性原理，在 CPU 芯片中加入了 TLB，负责缓存最近常被访问的页表项，大大提高了地址的转换速度。
  * 段页式内存管理：内存分段和内存分页组合起来后，通常称为段页式内存管理。
    * 简易流程：
      * 先将程序划分为多个有逻辑意义的段，也就是前面提到的分段机制
      * 再把每个段划分为多个页，也就是对分段划分出来的连续空间，再划分固定大小的页
      * 地址结构就由段号、段内页号和页内位移
    * 访问流程：
      * 第一次访问段表，得到页表起始地址；
      * 第二次访问页表，得到物理页号；
      * 第三次将物理页号与页内位移组合，得到物理地址。




用户态和内核态
  * 进程的堆栈：内核在创建进程的时候，在创建task_struct的同时，会为进程创建相应的堆栈。每个进程会有两个栈，一个用户栈，存在于用户空间，一个内核栈，存 在于内核空间
    * 当进程在用户空间运行时，cpu堆栈指针寄存器里面的内容是用户堆栈地址，使用用户栈
    * 当进程在内核空间时，cpu堆栈指针寄存器里面的内 容是内核栈空间地址，使用内核栈。
  * 进程用户栈和内核栈的切换
    * 进程陷入内核态后，先把用户态堆栈的地址保存在内核栈之中，然后设置堆栈指针寄存器的内容为内核栈的地址
    * 当进程从内 核态恢复到用户态之行时，在内核态之行的最后将保存在内核栈里面的用户栈的地址恢复到堆栈指针寄存器即可




  * 特权级：关键性的权力由高特权级的程序来执行，这样才可以做到集中管理，减少有限资源的访问和使用冲突
    * 0级最高，3级最低
    * 程序运行在3级特权级上时，就可以称之为运行在用户态
    * 当程序运行在0级特权级上时，就可以称之为运行在内核态




  * 用户态和内核态的转换：用户态切换到内核态的3种方式
    * 系统调用
      * 这是用户态进程主动要求切换到内核态的一种方式，用户态进程通过系统调用申请使用操作系统提供的服务程序完成工作，比如fork()实际上就是执行了一个创建新进程的系统调用。
    * 异常
      * 当CPU在执行运行在用户态下的程序时，发生了某些事先不可知的异常，这时会触发由当前运行进程切换到处理此异常的内核相关程序中，也就转到了内核态，比如缺页异常。
    * 外围设备的中断
      * 当外围设备完成用户请求的操作后，会向CPU发出相应的中断信号，这时CPU会暂停执行下一条即将要执行的指令转而去执行与中断信号对应的处理程序，如果先前执行的指令是用户态下的程序，那么这个转换的过程自然也就发生了由用户态到内核态的切换。比如硬盘读写操作完成，系统会切换到硬盘读写的中断处理程序中执行后续操作等




缺页中断
  * 缺页中断 ：指的是当软件试图访问已映射在虚拟地址空间中，但是目前并未被加载在物理内存中的一个分页时，由中央处理器的内存管理单元所发出的中断。
  * 情况分类：
    * 硬性
      * 与软性页缺失相反，硬性页缺失是指相关的页在页缺失发生时未被加载进内存的情况。这时操作系统需要：
        * 1\. 寻找到一个空闲的页。或者把另外一个使用中的页写到磁盘上（如果其在最后一次写入后发生了变化的话），并注销在MMU内的记录
        * 2\. 将数据读入被选定的页
        * 3\. 向MMU注册该页
    * 软性：
      * 软性页缺失指页缺失发生时，相关的页已经被加载进内存，但是没有向MMU注册的情况。操作系统只需要在MMU中注册相关页对应的物理地址即可。
    * 无效
      * 当程序访问的虚拟地址是不存在于虚拟地址空间内的时候，则发生无效页缺失。一般来说这是个软件问题，但是也不排除硬件可能，比如因为内存故障而损坏了一个正确的指针。
  * 处理步骤
    * 1\. 保护CPU现场

    * 2\. 分析中断原因
    * 3\. 转入缺页中断处理程序进行处理
    * 4\. 恢复CPU现场，继续执行




  * 页面置换算法：进程运行过程中，如果发生缺页中断，而此时内存中有没有空闲的物理块是，为了能够把所缺的页面装入内存，系统必须从内存中选择一页调出到磁盘的对换区。但此时应该把那个页面换出，则需要根据一定的页面置换算法（Page Replacement Algorithm)来确定
    * 最佳置换（Optimal， OPT)
      * 实现原理：每次选择未来长时间不被访问的或者以后永不使用的页面进行淘汰。
      * 缺点：最佳置换算法是一种理想化算法，具有较好的性能，但是实际上无法实现（无法预知一个进程中的若干页面哪一个最长时间不被访问）；
      * 优点：最佳置换算法可以保证获得最低的缺页率
    * 先进先出置换算法（First In First Out, FIFO)
      * 实现原理：淘汰最先进入内存的页面，即选择在页面待的时间最长的页面淘汰。
      * 优点：先进先出算法实现简单，是最直观的一个算法
      * 缺点：先进先出的性能最差，因为与通常页面的使用规则不符合，所以实际应用少
    * 最近最久未使用置换算法（Least Recently Used， LRU）
      * 实现原理：选择最近且最久未被使用的页面进行淘汰
      * 优点：由于考虑程序访问的时间局部性，一般能有较好的性能；实际应用多
      * 缺点：实现需要较多的硬件支持，会增加硬件成本

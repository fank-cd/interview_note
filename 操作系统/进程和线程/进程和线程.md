# 进程和线程
进程和线程
  * 进程：指在系统中正在运行的一个应用程序；程序一旦运行就是进程；进程——资源分配的最小单位。
    * 内存： 独立的地址空间
    * 文件/网络句柄”： 它们是所有的进程所共有的，例如打开同一个文件，去抢同一个网络的端口这样的操作是被允许的。
    * 线程
  * 线程：系统分配处理器时间资源的基本单元，或者说进程之内独立执行的一个单元执行流。线程——程序执行的最小单位。
    * 栈 :   我们通常都是说调用堆栈，其实这里的堆是没有含义的，调用堆栈就是调用栈的意思。 那么我们的栈里面有什么呢？ 我们从主线程的入口main函数，会不断的进行函数调用， 每次调用的时候，会把所有的参数和返回地址压入到栈中。
    * PC：  Program Counter 程序计数器，操作系统真正运行的是一个个的线程， 而我们的进程只是它的一个容器。PC就是指向当前的指令，而这个指令是放在内存中。 每个线程都有一串自己的指针，去指向自己当前所在内存的指针。 计算机绝大部分是存储程序性的，说的就是我们的数据和程序是存储在同一片内存里的 这个内存中既有我们的数据变量又有我们的程序。所以我们的PC指针就是指向我们的内存的。
    *  TLS:：  thread local storage 。 TLS可以用来存储我们线程所独有的数据。 可以看到：线程才是我们操作系统所真正去运行的，而进程呢，则是像容器一样他把需要的一些东西放在了一起，而把不需要的东西做了一层隔离，进行隔离开来。
  * 区别：
    * 线程：
      * 程序执行最小单位
      * 同一个进程下线程间共享地址空间
      * cpu切换线程开销小
      * 创建进程开销小
      * 线程占用资源少
      * 线程间通信更方便
      * 多线程程序更不易维护，一个线程死掉，整个进程就死掉了（因为共享地址空间）
      * 线程资源保护要求不高，但开销小，效率高，可频繁切换；
      *

    * 进程：
      * 资源分配最小单位
      * 独立地址空间
      * cpu切换进程开销大（需要在不同地址空间切换）
      * 创建进程开销大（因为需要单独创建独立的地址空间）
      * 进程占用资源大
      * 多进程程序更健壮，一个进程死掉不会对另一个进程造成影响（源于有独立的地址空间）
      * 进程对资源保护要求高，开销大，效率相对较低






进程间的通信方式
  1. 管道（匿名） :速度慢，容量有限，而且只能用于父子进程之间通讯
    * 半双工
    * 只能用于父子进程或者兄弟进程之间
    * 一个进程向管道中写的内容被管道的另一端进程读出
    * 存在于内存中的文件
  2. 管道（有名） :任意进程之间都可以使用，但是速度慢。
    * 遵循先进先出
    * 名字存在于文件系统中，内容存放在内存中
    * 可以在非情缘关系中传输
  3. 消息队列 :容量受到系统限制，且第一次读的时候，要考虑上一次没有读完的数据的问题
    * 遵循先进先出
    * 消息队列是存放在内核中的消息链表，每个消息队列由消息队列标识符表示。
    * 与管道不同的是消息队列存放在内核中，只有在内核重启(即，操作系统重启)或者显示地删除一个消息队列时，该消息队列才会被真正的删除。
    * 另外与管道不同的是，消息队列在某个进程往一个队列写入消息之前，并不需要另外某个进程在该队列上等待消息的到达.
    * 消息队列允许一个或多个进程向它写入与读取消息.
  4. 信号量 :不能用来传递复杂数据，只能用来同步
    * 信号是Linux系统中用于进程间互相通信或者操作的一种机制，信号可以在任何时候发给某一进程，而无需知道该进程的状态。
    * 如果该进程当前并未处于执行状态，则该信号就有内核保存起来，知道该进程回复执行并传递给它为止。
    * 如果一个信号被进程设置为阻塞，则该信号的传递被延迟，直到其阻塞被取消是才被传递给进程。
  5. 套接字
    * 一种通信机制
    * 既可以在本地允许，也可以跨网络允许
    * TCP/IP
    * 域、端口号、协议类型 组成




进程调度算法
  * 知识前置


    * 进程的状态：


      * 运行态：该状态表明进程在实际占用CPU
      * 就绪态: 该状态下进程可以运行，但因为其他进程正在运行而暂时停止
      * 阻塞态: 该状态下进程不能运行，除非某种外部事件的发送
    * 状态的变换
      * 运行态→等待态 往往是由于等待外设，等待主存等资源分配或等待人工干预而引起的。
      * 等待态→就绪态 则是等待的条件已满足，只需分配到处理器后就能运行。
      * 运行态→就绪态 不是由于自身原因，而是由外界原因使运行状态的进程让出处理器，这时候就变成就绪态。例如时间片用完，或有更高优先级的进程来抢占处理器等。
      * 就绪态→运行态 系统按某种策略选中就绪队列中的一个进程占用处理器，此时就变成了运行态
    * 处理机
      * 高级调度：(High-Level Scheduling)又称为作业调度，它决定把后备作业调入内存运行；
      * 低级调度：(Low-Level Scheduling)又称为进程调度，它决定把就绪队列的某进程获得CPU；
      * 中级调度：(Intermediate-Level Scheduling)又称为在虚拟存储器中引入，在内、外存对换区进行进程对换。




进程调度算法：调度算法是指：根据系统的资源分配策略所规定的资源分配算法
  * 先来先服务调度算法：
    * FCFS调度算法是一种最简单的调度算法，该调度算法既可以用于作业调度也可以用于进程调度。在作业调度中，算法每次从后备作业队列中选择最先进入该队列的一个或几个作业，将它们调入内存，分配必要的资源，创建进程并放入就绪队列。
    * 特点：
      * 算法简单
      * 效率低
      * 对长作业比较有利，但对短作业不利
      * 有利于CPU繁忙型作业，而不利于I/O繁忙型作业
  * 时间片轮转调度法
    * 时间片轮转调度算法主要适用于分时系统。在这种算法中，系统将所有就绪进程按到达时间的先后次序排成一个队列，进程调度程序总是选择就绪队列中第一个进程执行，即先来先服务的原则，但仅能运行一个时间片，如100ms。在使用完一个时间片后，即使进程并未完成其运行，它也必须释放出（被剥夺）处理机给下一个就绪的进程，而被剥夺的进程返回到就绪队列的末尾重新排队，等候再次运行。
    * 特点：
      * 时间片的大小对系统性能的影响很大
        * 如果时间片足够大，以至于所有进程都能在一个时间片内执行完毕，则时间片轮转调度算法就退化为先来先服务调度算法
        * 如果时间片很小，那么处理机将在进程间过于频繁切换，使处理机的开销增大，而真正用于运行用户进程的时间将减少。因此时间片的大小应选择适当
      * 时间片的长短通常由以下因素确定：系统的响应时间、就绪队列中的进程数目和系统的处理能力。
  * 短作业(SJF)优先调度算法
    * 短作业（进程）优先调度算法是指对短作业（进程）优先调度的算法。短作业优先(SJF)调度算法是从后备队列中选择一个或若干个估计运行时间最短的作业，将它们调入内存运行
    * 短作业优先调度算法是一个非抢占策略，他的原则是下一次选择预计处理时间最短的进程，因此短进程将会越过长作业，跳至队列头。该算法即可用于作业调度，也可用于进程调度。但是他对长作业不利，不能保证紧迫性作业（进程）被及时处理，作业的长短只是被估算出来的。
    * 特点：
      * 该算法对长作业不利，SJF调度算法中长作业的周转时间会增加。更严重的是，如果有一长作业进入系统的后备队列，由于调度程序总是优先调度那些 (即使是后进来的）短作业，将导致长作业长期不被调度（“饥饿”现象，注意区分“死锁”。后者是系统环形等待，前者是调度策略问题）。
      * 该算法完全未考虑作业的紧迫程度，因而不能保证紧迫性作业会被及时处理。
      * 由于作业的长短只是根据用户所提供的估计执行时间而定的，而用户又可能会有意或无意地缩短其作业的估计运行时间，致使该算法不一定能真正做到短作业优先调度。
  * 最短剩余时间优先
    * 最短剩余时间是针对最短进程优先增加了抢占机制的版本。在这种情况下，进程调度总是选择预期剩余时间最短的进程。当一个进程加入到就绪队列时，他可能比当前运行的进程具有更短的剩余时间，因此只要新进程就绪，调度程序就能可能抢占当前正在运行的进程。像最短进程优先一样，调度程序正在执行选择函数是必须有关于处理时间的估计，并且存在长进程饥饿的危险。
  * 高响应比优先调度算法
    * 根据比率：R=(w+s)/s （R为响应比，w为等待处理的时间，s为预计的服务时间）
    * 调度规则为：当前进程完成或被阻塞时，选择R值最大的就绪进程，它说明了进程的年龄。当偏向短作业时，长进程由于得不到服务，等待时间不断增加，从而增加比值，最终在竞争中赢了短进程。和最短进程优先、最短剩余时间优先一样，使用最高响应比策略需要估计预计服务时间。
    * 特点：
      * 当作业的等待时间相同时，则要求服务时间越短，其响应比越高，有利于短作业。
      * 当要求服务时间相同时，作业的响应比由其等待时间决定，等待时间越长，其响应比越高，因而它实现的是先来先服务。
      * 对于长作业，作业的响应比可以随等待时间的增加而提高，当其等待时间足够长时，其响应比便可升到很高，从而也可获得处理机。克服了饥饿状态，兼顾了长作业。
  * 优先级调度算法
    * 在作业调度中，优先级调度算法每次从后备作业队列中选择优先级最髙的一个或几个作业，将它们调入内存，分配必要的资源，创建进程并放入就绪队列。在进程调度中，优先级调度算法每次从就绪队列中选择优先级最高的进程，将处理机分配给它，使之投入运行。
    * 根据新的更高优先级进程能否抢占正在执行的进程，可将该调度算法分为：
      * 非剥夺式优先级调度算法。当某一个进程正在处理机上运行时，即使有某个更为重要或紧迫的进程进入就绪队列，仍然让正在运行的进程继续运行，直到由于其自身的原因而主动让出处理机时（任务完成或等待事件），才把处理机分配给更为重要或紧迫的进程。
      * 剥夺式优先级调度算法。当一个进程正在处理机上运行时，若有某个更为重要或紧迫的进程进入就绪队列，则立即暂停正在运行的进程，将处理机分配给更重要或紧迫的进程。
    * 而根据进程创建后其优先级是否可以改变，可以将进程优先级分为以下两种：
      * 静态优先级。优先级是在创建进程时确定的，且在进程的整个运行期间保持不变。确定静态优先级的主要依据有进程类型、进程对资源的要求、用户要求。
      * 动态优先级。在进程运行过程中，根据进程情况的变化动态调整优先级。动态调整优先级的主要依据为进程占有CPU时间的长短、就绪进程等待CPU时间的长短。
  * 多级反馈队列调度算法
    * 多级反馈队列调度算法的实现思想如下：
      * 1\. 应设置多个就绪队列，并为各个队列赋予不同的优先级，第1级队列的优先级最高，第2级队列次之，其余队列的优先级逐次降低。
      * 2\. 赋予各个队列中进程执行时间片的大小也各不相同，在优先级越高的队列中，每个进程的运行时间片就越小。例如，第2级队列的时间片要比第1级队列的时间片长一倍， ……第i+1级队列的时间片要比第i级队列的时间片长一倍。
      * 3\. 当一个新进程进入内存后，首先将它放入第1级队列的末尾，按FCFS原则排队等待调度。当轮到该进程执行时，如它能在该时间片内完成，便可准备撤离系统；如果它在一个时间片结束时尚未完成，调度程序便将该进程转入第2级队列的末尾，再同样地按FCFS 原则等待调度执行；如果它在第2级队列中运行一个时间片后仍未完成，再以同样的方法放入第3级队列……如此下去，当一个长进程从第1级队列依次降到第 n 级队列后，在第 n 级队列中便釆用时间片轮转的方式运行。
      * 4\. 仅当第1级队列为空时，调度程序才调度第2级队列中的进程运行；仅当第1 ~ (i-1)级队列均为空时，才会调度第i级队列中的进程运行。如果处理机正在执行第i级队列中的某进程时，又有新进程进入优先级较高的队列（第 1 ~ (i-1)中的任何一个队列），则此时新进程将抢占正在运行进程的处理机，即由调度程序把正在运行的进程放回到第i级队列的末尾，把处理机分配给新到的更高优先级的进程。
    * 特点：
      * 终端型作业用户：短作业优先。
      *  短批处理作业用户：周转时间较短。
      * 长批处理作业用户：经过前面几个队列得到部分执行，不会长期得不到处理。



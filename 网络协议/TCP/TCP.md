# TCP
**TCP： 是一种面向连接的、可靠的、基于字节流的传输层通信协议**

* * *

  * 在一个 TCP 连接中，仅有两方进行彼此通信。广播和多播不能用于 TCP

  * TCP 使用 **校验和** ， **确认** 和 **重传机制** 来保证 **可靠** 传输
  * TCP 给数据分节进行 **排序** ，并使用 **累积确认** 保证数据的 **顺序不变** 和 **非重复**
  * TCP 使用 **滑动窗口机制** 来实现 **流量控制** ，通过 **动态改变窗口** 的大小进行 **拥塞控制**




* * *


  * TCP 三次握手
    * 被动打开：由一端（服务器端）打开一个套接字（socket）然后监听来自另一方（客户端）的连接
      * 服务器执行了监听函数后，就在服务器上创建了两个队列
        * SYN队列：存放完成了二次握手的结果。 队列长度由listen函数的参数backlog指定。（也称为半连接队列）
        * ACCEPT队列：存放完成了三次握手的结果。队列长度由listen函数的参数backlog指定。（也成为全连接队列）
    * 三次握手过程：
      1. 客户端（通过执行connect函数）向服务器端发送一个SYN包，请求一个主动打开。该包携带客户端为这个连接请求而设定的随机数A作为消息序列号。
      2. 服务器端收到一个合法的SYN包后，把该包放入SYN队列中；回送一个SYN/ACK。ACK的确认码应为A+1，SYN/ACK包本身携带一个随机产生的序号B。
      3. 客户端收到SYN/ACK包后，发送一个Ack包，该包的序号被设定为A+1，而ACK的确认码则为B+1。然后客户端的connect函数成功返回。发送完毕后，客户端进入 ESTABLISHED 状态，当服务器端接收到这个包时，也进入 ESTABLISHED 状态，TCP 握手结束。
    * 问题一览：
      * 如果掉线：服务器端接到了客户端发的SYN后回了SYN-ACK后客户端掉线了，服务器端没有收到客户端回来的ACK，那么，这个连接处于一个中间状态，既没成功，也没失败。于是，服务器端如果在一定时间内没有收到的TCP会重发SYN-ACK。在Linux下，默认重试次数为5次，重试的间隔时间从1s开始每次都翻倍，5次的重试时间间隔为1s, 2s, 4s, 8s, 16s，总共31s
      * 如果发送的seq过期或者超时： 那么发送方就会直接发送 RST 控制消息中止这一次连接；
      * 三次握手中可以携带数据吗？：可以携带数据的。但是，第一次、第二次握手不可以携带数据，只能但三次。第一次不行是为了保护服务器不受攻击，第三次客户端已经是ESTABLISHED状态，所以可以。
      * 为什么需要三次握手：
        * 不采用三次握手，只要服务端发出确认，就建立新的连接了，此时客户端忽略服务端发来的确认，也不发送数据，则服务端一致等待客户端发送数据，浪费资源
        * 通过三次握手来确认双方的接受与发送能力是否正常
        * 如果是两次握手：如客户端发出连接请求，但因连接请求报文丢失而未收到确认，于是客户端再重传一次连接请求。后来收到了确认，建立了连接。数据传输完毕后，就释放了连接，客户端共发出了两个连接请求报文段，其中第一个丢失，第二个到达了服务端，但是第一个丢失的报文段只是在某些网络结点长时间滞留了，延误到连接释放以后的某个时间才到达服务端，此时服务端误认为客户端又发出一次新的连接请求，于是就向客户端发出确认报文段，同意建立连接
      * SYN攻击是什么：SYN攻击就是Client在短时间内伪造大量不存在的IP地址，并向Server不断地发送SYN包，Server则回复确认包，并等待Client确认，由于源地址不存在，因此Server需要不断重发直至超时，这些伪造的SYN包将长时间占用未连接队列，导致正常的SYN请求因为队列满而被丢弃，从而引起网络拥塞甚至系统瘫痪
        * 如何检测： netstat -n -p TCP | grep SYN_RECV
        * 如何防御：
          * 缩短超时（SYN Timeout）时间
          * 增加最大半连接数
          * 过滤网关防护
          * SYN cookies技术


![noteattachment1][bd5f217251f3c98521c3dfc508c2d227]


* * *


  * TCP四次挥手：
    * 四次挥手过程：
      * 第一次挥手(FIN=1，seq=x)
        * 假设客户端想要关闭连接，客户端发送一个 FIN 标志位置为1的包，表示自己已经没有数据可以发送了，但是仍然可以接受数据。发送完毕后，客户端进入 FIN_WAIT_1 状态。
      * 第二次挥手(ACK=1，ACKnum=x+1)
        * 服务器端确认客户端的 FIN 包，发送一个确认包，表明自己接受到了客户端关闭连接的请求，但还没有准备好关闭连接。发送完毕后，服务器端进入 CLOSE_WAIT 状态，客户端接收到这个确认包之后，进入 FIN_WAIT_2 状态，等待服务器端关闭连接。
      * 第三次挥手(FIN=1，seq=y)
        * 服务器端准备好关闭连接时，向客户端发送结束连接请求，FIN 置为1。发送完毕后，服务器端进入 LAST_ACK 状态，等待来自客户端的最后一个ACK。
      * 第四次挥手(ACK=1，ACKnum=y+1)
        * 客户端接收到来自服务器端的关闭请求，发送一个确认包，并进入 TIME_WAIT状态，等待可能出现的要求重传的 ACK 包。服务器端接收到这个确认包之后，关闭连接，进入 CLOSED 状态。客户端等待了某个固定时间（两个最大段生命周期，2MSL，2 Maximum Segment Lifetime）之后，没有收到服务器端的 ACK ，认为服务器端已经正常关闭连接，于是自己也关闭连接，进入 CLOSED 状态。


    * 问题一览：
      * 为什么挥手需要四次：关闭连接时，当服务端收到FIN报文时，很可能并不会立即关闭SOCKET，所以只能先回复一个ACK报文，告诉客户端，"你发的FIN报文我收到了"。只有等到我服务端所有的报文都发送完了，我才能发送FIN报文，因此不能一起发送。故需要四次挥手。
      * TIME_WAIT状态：
        * 确认服务端收到了FIN对应的ACK请求，以便能重传ACK请求，确保服务端能正确地关闭。
        * 防止延迟的数据段被其他使用相同源地址、源端口、目的地址以及目的端口的 TCP 连接收到
      * 为什么需要2MSL
        * MSL：静默数据段在网络中能够存活的最长时间
        * 网络中可能存在来自发起方的数据段，当这些发起方的数据段被服务端处理后又会向客户端发送响应。客户端在发送完最后一个ACK报文段后，再经过2MSL，就可以使本连接持续的时间内所产生的所有报文段都从网络中消失
      * TCP 在什么情况下服务端会出现大量 CLOSE_WAIT ？
        * 服务端接收到客户端的FIN后，并没有发送 FIN，导致服务端一直处于 CLOSE_WAIT 状态，无法最终进入 CLOSED 状态
        * 连接没有正确释放
        * 在递归中调用了连接，产生了死锁




![noteattachment2][8f5c3411331180d34888579a78c6d867]





---
### ATTACHMENTS
[bd5f217251f3c98521c3dfc508c2d227]: media/2021-02-18_03-26-57.jpg
[2021-02-18_03-26-57.jpg](media/2021-02-18_03-26-57.jpg)
>hash: bd5f217251f3c98521c3dfc508c2d227
>file-name: 三次握手.jpg

[8f5c3411331180d34888579a78c6d867]: media/2021-02-18_03-26-57.png
[2021-02-18_03-26-57.png](media/2021-02-18_03-26-57.png)
>hash: 8f5c3411331180d34888579a78c6d867
>file-name: 四次挥手.png

# HTTP和HTTPS
  * HTTP 的特性
    * HTTP 协议构建于 TCP/IP 协议之上，是一个应用层协议，默认端口号是 80
    * HTTP 是无连接无状态的
    * HTTP 协议是以 ASCII 码传输，建立在 TCP/IP 协议之上的应用层规范
  * HTTP 的方法
    * GET
      * GET方法用于使用给定的URI从给定服务器中检索信息，即从指定资源中请求数据。使用GET方法的请求应该只是检索数据，并且不应对数据产生其他影响。在GET请求的URL中发送查询字符串mGET请求是可以缓存的，我们可以从浏览器历史记录中查找到GET请求，还可以把它收藏到书签中；且GET请求有长度限制，仅用于请求数据（不修改）。
      * tips：因GET请求的不安全性，在处理敏感数据时，绝不可以使用GET请求
    * POST
      * POST方法用于将数据发送到服务器以创建或更新资源，它要求服务器确认请求中包含的内容作为由URI区分的Web资源的另一个下属。POST请求永远不会被缓存，且对数据长度没有限制；我们无法从浏览器历史记录中查找到POST请求。
    * HEAD
      * HEAD方法与GET方法相同，但没有响应体，仅传输状态行和标题部分。这对于恢复相应头部编写的元数据非常有用，而无需传输整个内容。
    * PUT
      * PUT方法用于将数据发送到服务器以创建或更新资源，它可以用上传的内容替换目标资源中的所有当前内容。它会将包含的元素放在所提供的URI下，如果URI指示的是当前资源，则会被改变。如果URI未指示当前资源，则服务器可以使用该URI创建资源。
    * DELETE
      * DELETE方法用来删除指定的资源，它会删除URI给出的目标资源的所有当前内容。
    * CONNECT
      * CONNECT方法用来建立到给定URI标识的服务器的隧道；它通过简单的TCP / IP隧道更改请求连接，通常实使用解码的HTTP代理来进行SSL编码的通信（HTTPS）。
    * OPTIONS
      * OPTIONS方法用来描述了目标资源的通信选项，会返回服务器支持预定义URL的HTTP策略。
    * TRACE
      * TRACE方法用于沿着目标资源的路径执行消息环回测试；它回应收到的请求，以便客户可以看到中间服务器进行了哪些（假设任何）进度或增量。
    * tips：
      * GET 可提交的数据量受到URL长度的限制，HTTP 协议规范没有对 URL 长度进行限制。这个限制是特定的浏览器及服务器对它的限制
      * 理论上讲，POST 是没有大小限制的，HTTP 协议规范也没有进行大小限制，出于安全考虑，服务器软件在实现时会做一定限制





方法|说明|支持的HTTP协议版本
---|---|---
GET|获取资源|1.0\1.1POST|传输实体主体|
1.0\1.1
PUT
|
传输文件
|
1.0\1.1
HEAD
|
获得报文头部
|
1.0\1.1
DELETE
|
删除文件
|
1.0\1.1
OPTIONS
|
询问支持的方法
|
1.1
TRACE
|
追踪路径
|
1.1
CONNECT
|
要求用隧道协议链接代理
|
1.1
LINK
|
建立和资源之间的关系
|
1.0
UNLINK
|
断开连接关系
|
1.0


###
###

  * 响应报文：HTTP 响应与 HTTP 请求相似，HTTP响应也由3个部分构成，分别是：
    * 状态行：状态行由协议版本、数字形式的状态代码、及相应的状态描述，各元素之间以空格分隔。
    * 响应头(Response Header)
    * 响应正文
  *

  * 常见的状态码有如下几种：
    * 1xx：指示信息–表示请求已接收，继续处理。
    * 2xx：成功–表示请求已被成功接收、理解、接受。
    * 3xx：重定向–要完成请求必须进行更进一步的操作。
    * 4xx：客户端错误–请求有语法错误或请求无法实现。
    * 5xx：服务器端错误–服务器未能实现合法的请求。
  * 具体的状态码：
  * 200 OK 客户端请求成功
  * 301 Moved Permanently 请求永久重定向
  * 302 Moved Temporarily 请求临时重定向
  * 304 Not Modified 文件未修改，可以直接使用缓存的文件。
  * 400 Bad Request 由于客户端请求有语法错误，不能被服务器所理解。
  * 401 Unauthorized 请求未经授权。这个状态代码必须和WWW-Authenticate报头域一起使用
  * 403 Forbidden 服务器收到请求，但是拒绝提供服务。服务器通常会在响应正文中给出不提供服务的原因
  * 404 Not Found 请求的资源不存在，例如，输入了错误的URL
  * 500 Internal Server Error 服务器发生不可预期的错误，导致无法完成客户端的请求。
  * 503 Service Unavailable 服务器当前不能够处理客户端的请求，在一段时间之后，服务器可能会恢复正常。








  * 会话跟踪
    * 什么是会话
      * 客户端打开与服务器的连接发出请求到服务器响应客户端请求的全过程称之为会话。
    *  什么是会话跟踪？
      * 会话跟踪指的是对同一个用户对服务器的连续的请求和接受响应的监视。
    *  为什么需要会话跟踪？
      * 浏览器与服务器之间的通信是通过HTTP协议进行通信的，而HTTP协议是”无状态”的协议，它不能保存客户的信息，即一次响应完成之后连接就断开了，下一次的请求需要重新连接，这样就需要判断是否是同一个用户，所以才有会话跟踪技术来实现这种要求。
    * 会话跟踪常用的方法:
      * URL 重写
        * URL(统一资源定位符)是Web上特定页面的地址，URL重写的技术就是在URL结尾添加一个附加数据以标识该会话,把会话ID通过URL的信息传递过去，以便在服务器端进行识别不同的用户。
      * 隐藏表单域
        * 将会话ID添加到HTML表单元素中提交到服务器，此表单元素并不在客户端显示
      * Cookie
        * Cookie 是Web 服务器发送给客户端的一小段信息，客户端请求时可以读取该信息发送到服务器端，进而进行用户的识别。对于客户端的每次请求，服务器都会将 Cookie 发送到客户端,在客户端可以进行保存,以便下次使用。客户端可以采用两种方式来保存这个 Cookie 对象，一种方式是保存在客户端内存中，称为临时 Cookie，浏览器关闭后这个 Cookie 对象将消失。另外一种方式是保存在客户机的磁盘上，称为永久 Cookie。以后客户端只要访问该网站，就会将这个 Cookie 再次发送到服务器上，前提是这个 Cookie 在有效期内，这样就实现了对客户的跟踪。
        * Cookie 是可以被客户端禁用的。
      *  Session:
        * 每一个用户都有一个不同的 session，各个用户之间是不能共享的，是每个用户所独享的，在 session 中可以存放信息。在服务器端会创建一个 session 对象，产生一个 sessionID 来标识这个 session 对象，然后将这个 sessionID 放入到 Cookie 中发送到客户端，下一次访问时，sessionID 会发送到服务器，在服务器端进行识别不同的用户。Session 的实现依赖于 Cookie，如果 Cookie 被禁用，那么 session 也将失效。
  * 跨域：指与当前不同源的地址发送的请求，它允许浏览器向跨源服务器，发出XMLHttpRequest请求，从而克服了AJAX只能同源使用的限制。
    * 同源：同源是指，域名，协议，端口均相同
    * 跨域：指与当前不同源的地址发送的请求，它允许浏览器向跨源服务器，发出XMLHttpRequest请求，从而克服了AJAX只能同源使用的限制。
    * 为什么需要跨域：浏览器会对上面提到的跨域请求作出限制。浏览器之所以要对跨域请求作出限制，是出于安全方面的考虑，因为跨域请求有可能被不法分子利用来发动 CSRF攻击。、
    * CORS需要浏览器和服务器同时支持
    * 浏览器将CORS请求分成两类：简单请求（simple request）和非简单请求（not-so-simple request）
      1. 简单请求
        * 请求方法是以下三种方法之一：
          * HEAD
          * GET
          * POST
        * HTTP的头信息不超出以下几种字段：
          * Accept
          * Accept-Language
          * Content-Language
          * Last-Event-ID
          * Content-Type：只限于三个值application/x-www-form-urlencoded、multipart/form-data、text/plain、
        *

      * 非简单请求外的即为非简单请求
        * 非简单请求是那种对服务器有特殊要求的请求，比如请求方法是PUT或DELETE，或者Content-Type字段的类型是application/json。
        * 非简单请求的CORS请求，会在正式通信之前，增加一次HTTP查询请求，称为"预检"请求（preflight）
    * CORS请求默认不发送Cookie和HTTP认证信息，如果要把Cookie发到服务器，一方面要服务器同意，指定Access-Control-Allow-Credentials字段
    * 如何实现跨域：
      * JSONP跨域
      * 代理服务器（nginx）
      * 协议跨域 (跨域资源访问CORS)
  * CSRF（Cross-site request forgery，跨站请求伪造）：CSRF(XSRF) 顾名思义，是伪造请求，冒充用户在站内的正常操作。
  * 例

```
一论坛网站的发贴是通过 GET 请求访问，点击发贴之后 JS 把发贴内容拼接成目标 URL 并访问：
 http://example.com/bbs/create_post.php?title=标题&content=内容
那么，我们只需要在论坛中发一帖，包含一链接：
  http://example.com/bbs/create_post.php?title=我是脑残&content=哈哈
只要有用户点击了这个链接，那么他们的帐户就会在不知情的情况下发布了这一帖子。可能这只是个恶作剧，但是既然发贴的请求可以伪造，那么删帖、转帐、改密码、发邮件全都可以伪造。
```
  * 如何防范 CSRF 攻击
    * 关键操作只接受 POST 请求
    *  验证码
      * CSRF 攻击的过程，往往是在用户不知情的情况下构造网络请求。所以如果使用验证码，那么每次操作都需要用户进行互动，从而简单有效的防御了CSRF攻击。但是如果你在一个网站作出任何举动都要输入验证码会严重影响用户体验，所以验证码一般只出现在特殊操作里面，或者在注册时候使用。
    * 检测 Referer
      * 常见的互联网页面与页面之间是存在联系的，比如你在 www.baidu.com 应该是找不到通往www.google.com 的链接的，再比如你在论坛留言，那么不管你留言后重定向到哪里去了，之前的那个网址一定会包含留言的输入框，这个之前的网址就会保留在新页面头文件的 Referer 中通过检查 Referer 的值，我们就可以判断这个请求是合法的还是非法的，但是问题出在服务器不是任何时候都能接受到 Referer 的值，所以 Referer Check 一般用于监控 CSRF 攻击的发生，而不用来抵御攻击。
    * Token
      * 目前主流的做法是使用 Token 抵御 CSRF 攻击。CSRF 攻击要成功的条件在于攻击者能够预测所有的参数从而构造出合法的请求。所以根据不可预测性原则，我们可以对参数进行加密从而防止 CSRF 攻击。
      * 另一个更通用的做法是保持原有参数不变，另外添加一个参数 Token，其值是随机的。这样攻击者因为不知道 Token 而无法构造出合法的请求进行攻击。
      * Token 使用原则
        * Token 要足够随机————只有这样才算不可预测
        * Token 是一次性的，即每次请求成功后要更新Token————这样可以增加攻击难度，增加预测难度
        * Token 要注意保密性————敏感操作使用 post，防止 Token 出现在 URL 中
      * 注意：过滤用户输入的内容不能阻挡 csrf，我们需要做的是过滤请求的来源。
  * XSS（Cross Site Scripting，跨站脚本攻击）
    * XSS 全称“跨站脚本”，是注入攻击的一种。其特点是不对服务器端造成任何伤害，而是通过一些正常的站内交互途径，例如发布评论，提交含有 JavaScript 的内容文本。这时服务器端如果没有过滤或转义掉这些脚本，作为内容发布到了页面上，其他用户访问这个页面的时候就会运行这些脚本。
  * 如何防御
    * 过滤用户的输入：
      * 理论上，所有可输入的地方没有对输入数据进行处理的话，都会存在 XSS 漏洞，漏洞的危害取决于攻击代码的威力，攻击代码也不局限于 script。防御 XSS 攻击最简单直接的方法，就是过滤用户的输入。




* * *
  * Cookie、Session、Token、JWT
  * cookie：
      * HTTP 是无状态的协议（对于事务处理没有记忆能力，每次客户端和服务端会话完成时，服务端不会保存任何会话信息）：每个请求都是完全独立的，服务端无法确认当前访问者的身份信息，无法分辨上一次的请求发送者和这一次的发送者是不是同一个人。所以服务器与浏览器为了进行会话跟踪（知道是谁在访问我），就必须主动的去维护一个状态，这个状态用于告知服务端前后两个请求是否来自同一浏览器。而这个状态需要通过 cookie 或者 session 去实现。
      * cookie 存储在客户端： cookie 是服务器发送到用户浏览器并保存在本地的一小块数据，它会在浏览器下次向同一服务器再发起请求时被携带并发送到服务器上。
      * cookie 是不可跨域的： 每个 cookie 都会绑定单一的域名，无法在别的域名下获取使用，一级域名和二级域名之间是允许共享使用的（靠的是 domain）。
    * cookie属性：
      * name=value
        * 键值对，设置 Cookie 的名称及相对应的值，都必须是字符串类型/
        * 如果值为 Unicode 字符，需要为字符编码
        * 如果值为二进制数据，则需要使用 BASE64 编码。
      * domain:
        * 指定 cookie 所属域名，默认是当前域名
      * path
        * 指定 cookie 在哪个路径（路由）下生效，默认是 '/'。如果设置为 /abc，则只有 /abc 下的路由可以访问到该 cookie，如：/abc/read。
      * maxAge
        * cookie 失效的时间，单位秒。如果为整数，则该 cookie 在 maxAge 秒后失效。如果为负数，该 cookie 为临时 cookie ，关闭浏览器即失效，浏览器也不会以任何形式保存该 cookie 。如果为 0，表示删除该 cookie 。默认为 -1。
      * expires
        * 过期时间，在设置的某个时间点后该 cookie 就会失效。一般浏览器的 cookie 都是默认储存的，当关闭浏览器结束这个会话的时候，这个 cookie 也就会被删除
      * secure
        * 该 cookie 是否仅被使用安全协议传输。安全协议有 HTTPS，SSL等，在网络上传输数据之前先将数据加密。默认为false。
        * 当 secure 值为 true 时，cookie 在 HTTP 中是无效，在 HTTPS 中才有效。
      * httpOnly
        * 如果给某个 cookie 设置了 httpOnly 属性，则无法通过 JS 脚本 读取到该 cookie 的信息，但还是能通过 Application 中手动修改 cookie，所以只是在一定程度上可以防止 XSS 攻击，不是绝对的安全
  * session
      * session 是另一种记录服务器和客户端会话状态的机制
      * session 是基于 cookie 实现的，session 存储在服务器端，sessionId 会被存储到客户端的cookie 中


    * session 认证流程：
      1. 用户第一次请求服务器的时候，服务器根据用户提交的相关信息，创建对应的 Session
      2. 请求返回时将此 Session 的唯一标识信息 SessionID 返回给浏览器
      3. 浏览器接收到服务器返回的 SessionID 信息后，会将此信息存入到 Cookie 中，同时 Cookie 记录此 SessionID 属于哪个域名
      4. 当用户第二次访问服务器的时候，请求会自动判断此域名下是否存在 Cookie 信息，如果存在自动将 Cookie 信息也发送给服务端，服务端会从 Cookie 中获取 SessionID，再根据 SessionID 查找对应的 Session 信息，如果没有找到说明用户没有登录或者登录失效，如果找到 Session 证明用户已经登录可执行后面操作。
    * Cookie 和 Session 的区别
      * 安全性： Session 比 Cookie 安全，Session 是存储在服务器端的，Cookie 是存储在客户端的。
      * 存取值的类型不同：Cookie 只支持存字符串数据，想要设置其他类型的数据，需要将其转换成字符串，Session 可以存任意数据类型。
      * 有效期不同： Cookie 可设置为长时间保持，比如我们经常使用的默认登录功能，Session 一般失效时间较短，客户端关闭（默认情况下）或者 Session 超时都会失效。
      * 存储大小不同： 单个 Cookie 保存的数据不能超过 4K，Session 可存储数据远高于 Cookie，但是当访问量过多，会占用过多的服务器资源
    *

  * Acesss Token
      * 访问资源接口（API）时所需要的资源凭证
      * 简单 token 的组成： uid(用户唯一的身份标识)、time(当前时间的时间戳)、sign（签名，token 的前几位以哈希算法压缩成的一定长度的十六进制字符串）
    * 特点：
      * 服务端无状态化、可扩展性好
      * 支持移动端设备
      * 安全
      * 支持跨程序调用】
    * Token认证流程
      1. 客户端使用用户名跟密码请求登录
      2. 服务端收到请求，去验证用户名与密码
      3. 验证成功后，服务端会签发一个 token 并把这个 token 发送给客户端
      4. 客户端收到 token 以后，会把它存储起来，比如放在 cookie 里或者 localStorage 里
      5. 客户端每次向服务端请求资源的时候需要带着服务端签发的 token
      6. 服务端收到请求，然后去验证客户端请求里面带着的 token ，如果验证成功，就向客户端返回请求的数据
    * Token 特点：
      * 每一次请求都需要携带 token，需要把 token 放到 HTTP 的 Header 里
      * 基于 token 的用户认证是一种服务端无状态的认证方式，服务端不用存放 token 数据。用解析 token 的计算时间换取 session 的存储空间，从而减轻服务器的压力，减少频繁的查询数据库
      * token 完全由应用管理，所以它可以避开同源策略（可）
    * Token 和 Session 的区别
      * Session 是一种记录服务器和客户端会话状态的机制，使服务端有状态化，可以记录会话信息。而 Token 是令牌，访问资源接口（API）时所需要的资源凭证。Token 使服务端无状态化，不会存储会话信息。
      * Session 和 Token 并不矛盾，作为身份认证 Token 安全性比 Session 好，因为每一个请求都有签名还能防止监听以及重放攻击，而 Session 就必须依赖链路层来保障通讯安全了。如果你需要实现有状态的会话，仍然可以增加 Session 来在服务器端保存一些状态。
      * 所谓 Session 认证只是简单的把 User 信息存储到 Session 里，因为 SessionID 的不可预测性，暂且认为是安全的。而 Token ，如果指的是 OAuth Token 或类似的机制的话，提供的是 认证 和 授权 ，认证是针对用户，授权是针对 App 。其目的是让某 App 有权利访问某用户的信息。这里的 Token 是唯一的。不可以转移到其它 App上，也不可以转到其它用户上。Session 只提供一种简单的认证，即只要有此 SessionID ，即认为有此 User 的全部权利。是需要严格保密的，这个数据应该只保存在站方，不应该共享给其它网站或者第三方 App。所以简单来说：如果你的用户数据可能需要和第三方共享，或者允许第三方调用 API 接口，用 Token 。如果永远只是自己的网站，自己的 App，用什么就无所谓了。
  * JSON Web Token（简称 JWT）是目前最流行的跨域认证解决方案。
  * JWT 的原理
    * JWT 的原理是，服务器认证以后，生成一个 JSON 对象，发回给用户，就像下面这样。

```
{
  "姓名": "张三",
  "角色": "管理员",
  "到期时间": "2018年7月1日0点0分"}
}
```
    * 用户与服务端通信的时候，都要发回这个 JSON 对象。服务器完全只靠这个对象认定用户身份。为了防止用户篡改数据，服务器在生成这个对象的时候，会加上签名。服务器就不保存任何 session 数据了，也就是说，服务器变成无状态了，从而比较容易实现扩展。
  * JWT 的数据结构
    * 它是一个很长的字符串，中间用点（.）分隔成三个部分。注意，JWT 内部是没有换行的，这里只是为了便于展示，将它写成了几行。
    * JWT 的三个部分依次如下。
      * Header（头部）
      * Payload（负载）
      * Signature（签名）
    * 写成一行，就是下面的样子。
      * Header.Payload.Signature
    * Header
      * 部分是一个 JSON 对象，描述 JWT 的元数据，通常是下面的样子。
      * Header

```
{
  "alg": "HS256",
  "typ": "JWT"}
```
      * 上面代码中，alg属性表示签名的算法（algorithm），默认是 HMAC SHA256（写成 HS256）；typ属性表示这个令牌（token）的类型（type），JWT 令牌统一写为JWT。
      * 最后，将上面的 JSON 对象使用 Base64URL 算法转成字符串。
    * Payload：
      * Payload 部分也是一个 JSON 对象，用来存放实际需要传递的数据。JWT 规定了7个官方字段，供选用。
        * iss (issuer)：签发人
        * exp (expiration time)：过期时间
        * sub (subject)：主题
        * aud (audience)：受众
        * nbf (Not Before)：生效时间
        * iat (Issued At)：签发时间
        * jti (JWT ID)：编号
      * 除了官方字段，你还可以在这个部分定义私有字段，下面就是一个例子。
      * 注意，JWT 默认是不加密的，任何人都可以读到，所以不要把秘密信息放在这个部分。
      * 这个 JSON 对象也要使用 Base64URL 算法转成字符串。


    * Signature
      * 首先，需要指定一个密钥（secret）。这个密钥只有服务器才知道，不能泄露给用户。然后，使用 Header 里面指定的签名算法（默认是 HMAC SHA256），按照下面的公式产生签名。

```
HMACSHA256(
  base64UrlEncode(header) + "." +
  base64UrlEncode(payload),
  secret)
```
      * 算出签名以后，把 Header、Payload、Signature 三个部分拼成一个字符串，每个部分之间用"点"（.）分隔，就可以返回给用户。
    * Base64URL
      * 前面提到，Header 和 Payload 串型化的算法是 Base64URL。这个算法跟 Base64 算法基本类似，但有一些小的不同。
      * JWT 作为一个令牌（token），有些场合可能会放到 URL（比如 api.example.com/?token=xxx）。Base64 有三个字符+、/和=，在 URL 里面有特殊含义，所以要被替换掉：=被省略、+替换成-，/替换成_ 。这就是 Base64URL 算法。
  * JWT 的使用方式
    * 放在 Cookie，但是这样不能跨域
    * 放在localStorage
    * 放在 HTTP 请求的头信息Authorization字段里面
  * JWT 的几个特点
    * JWT 默认是不加密，但也是可以加密的。生成原始 Token 以后，可以用密钥再加密一次。
    * JWT 不加密的情况下，不能将秘密数据写入 JWT。
    * JWT 不仅可以用于认证，也可以用于交换信息。有效使用 JWT，可以降低服务器查询数据库的次数。
    * JWT 的最大缺点是，由于服务器不保存 session 状态，因此无法在使用过程中废止某个 token，或者更改 token 的权限。也就是说，一旦 JWT 签发了，在到期之前就会始终有效，除非服务器部署额外的逻辑。
    * JWT 本身包含了认证信息，一旦泄露，任何人都可以获得该令牌的所有权限。为了减少盗用，JWT 的有效期应该设置得比较短。对于一些比较重要的权限，使用时应该再次对用户进行认证。
    * 为了减少盗用，JWT 不应该使用 HTTP 协议明码传输，要使用 HTTPS 协议传输。




* * *
  * HTTPS：用非对称加密的方法传输对称密钥后进行的加密通信
    * 数字证书：由CA颁发的，用以证明服务器身份，以防范中间人攻击。由以下两部分组成：
      * 服务器信息、服务器公钥
      * 数字签名：将服务器的信息及公钥用哈希算法取得消息摘要后，再用CA的私钥进行加密
        * CA私钥加密（HASH（服务器信息+服务器公钥））
      * 如何认证？
        * 客户端通过同样的Hash 算法， 再次生成消息摘要，然后用CA的公钥对数字签名解密， 得到CA创建的消息摘要，与数字签名进行比对
        * 如何确定CA的 合法性：
          * 系统和浏览器内置有根证书，不断向上回溯，一步步验证CA是否合法
      *  认证过程：
        1. 客户端获取到了站点证书，拿到了站点的公钥
        2. 客户端找到其站点证书颁发者的信息
        3. 站点证书的颁发者验证服务端站点是否可信
        4. 往上回溯，找到根证书颁发者
        5. 通过根证书颁发者一步步验证站点证书颁布者是否可信
    * TLS建立连接过程：
      * Client Hello:
        * 握手第一步是客户端向服务端发送 Client Hello 消息，这个消息里包含了一个客户端生成的随机数 Random1、客户端支持的加密套件（Support Ciphers）和 SSL Version 等信息
      * Server Hello
        * :第二步是服务端向客户端发送 Server Hello 消息，这个消息会从 Client Hello 传过来的 Support Ciphers 里确定一份加密套件，这个套件决定了后续加密和生成摘要时具体使用哪些算法，另外还会生成一份随机数 Random2。注意，至此客户端和服务端都拥有了两个随机数（Random1+ Random2），这两个随机数会在后续生成对称秘钥时用到。
      * Certificate:
        * 这一步是服务端将自己的证书下发给客户端，让客户端验证自己的身份，客户端验证通过后取出证书中的公钥
      * Server Hello Done:
        * 通知客户端 Server Hello 过程结束。
      * Certificate Verify:
        * 客户端收到服务端传来的证书后，先从 CA 验证该证书的合法性，验证通过后取出证书中的服务端公钥，再生成一个随机数 Random3，再用服务端公钥非对称加密 Random3生成 PreMaster Key
      * Cient Key Exchange:
        * 面客户端根据服务器传来的公钥生成了 PreMaster Key，Client Key Exchange 就是将这个 key 传给服务端，服务端再用自己的私钥解出这个 PreMaster Key 得到客户端生成的 Random3。至此，客户端和服务端都拥有 Random1 + Random2 + Random3，两边再根据同样的算法就可以生成一份秘钥，握手结束后的应用层数据都是使用这个秘钥进行对称加密。为什么要使用三个随机数呢？这是因为 SSL/TLS 握手过程的数据都是明文传输的，并且多个随机数种子来生成秘钥不容易被暴力破解出来。
      * Change Cipher Spec(Client):
        * 这一步是客户端通知服务端后面再发送的消息都会使用前面协商出来的秘钥加密了，是一条事件消息
      * Encrypted Handshake Message(Client):
        * 这一步对应的是 Client Finish 消息，客户端将前面的握手消息生成摘要再用协商好的秘钥加密，这是客户端发出的第一条加密消息。服务端接收后会用秘钥解密，能解出来说明前面协商出来的秘钥是一致的
      * Change Cipher Spec(Server)
        * :这一步是服务端通知客户端后面再发送的消息都会使用加密，也是一条事件消息
      * Encrypted Handshake Message(Server):
        * 这一步对应的是 Server Finish 消息，服务端也会将握手过程的消息生成摘要再用秘钥加密，这是服务端发出的第一条加密消息。客户端接收后会用秘钥解密，能解出来说明协商的秘钥是一致的。
      * Application Data
        * 到这里，双方已安全地协商出了同一份秘钥，所有的应用层数据都会用这个秘钥加密后再通过 TCP 进行可靠传输






HTTP 与 HTTPS 有哪些区别？
  * HTTP：是互联网上应用最为广泛的一种网络协议，是一个客户端和服务器端请求和应答的标准（TCP），用于从WWW服务器传输超文本到本地浏览器的传输协议，它可以使浏览器更加高效，使网络传输减少。
  * HTTPS：是以安全为目标的HTTP通道，简单讲是HTTP的安全版，即HTTP下加入SSL层，HTTPS的安全基础是SSL，因此加密的详细内容就需要SSL。








|
HTTPS
|
HTTP
---|---|---
传输内容
|
密文
|
明文
使用协议
|
SSL
|
TCP
连接端口
|
443
|
80
身份验证
|
有
|
无
验证方式
|
CA验证
|
无
建立连接
|
12次握手（TCP3次，SSL9次）
|
3次握手


HTTP缺点：
  1. 通信使用明文，内容可能会被窃听


  1. 不验证通信方的身份，因此有可能遭遇伪装
  2. 无法验证报文的完整性，所以有可能遭篡改




* * *
对称加密和非对称加密的
  * 对称加密：指加密和解密使用相同密钥的加密算法。
    * 特点：对称加密算法的特点是算法公开、计算量小、加密速度快、加密效率高。
    * 缺点：
      1. 交易双方都使用同样钥匙，安全性得不到保证。
      2. 每对用户每次使用对称加密算法时，都需要使用其他人不知道的惟一钥匙，这会使得发收信双方所拥有的钥匙数量呈几何级数增长， 密钥管理成为用户的负担。
      3. 密钥在传输过程中遭受中间人攻击可能会受通信不安全
      4. 对称加密算法一般不能提供信息完整性的鉴别。它无法验证发送者和接受者的身份；
    * 具体算法：DES算法，3DES算法，TDEA算法， Blowfish算法， RC5 算法，IDEA算法。
  * 非对称加密：非对称加密算法需要两个密钥: 公开密钥(publickey)和私有密钥(privatekey)。公开密钥与私有密钥是一对，如果用公开密钥对数据进行加密，只有用对应的私有密钥才能解密;如果用私有密钥对数据进行加密，那么只有用对应的公开密钥才能解密。因为加密和解密使用的是两个不同的密钥，所以这种算法叫作非对称加密算法。
    * 优劣：
      * 非对称加密使用了一对密钥，公钥与私钥，所以安全性高
      * 加密与解密速度慢。非对称加密的RSA加密效率较低，一次加密的数据大小也很局限
    * 过程：
      1. A生成一对密钥，并将其中的一把作为公用密钥发送给B
      2. B得到该公钥，使用该公钥对机密信息进行加密后再发送给甲方，（其中也可以包含自己的公钥）
      3. A方收到后再用私钥对加密信息进行解密
    * 具体算法：RSA、Elgamal、背包算法、Rabin、HD,ECC（椭圆曲线加密算法）。
  * 其他：
    * 消息摘要算法:Hash算法特别的地方在于它是一种单向算法，用户可以通过Hash算法对目标信息生成一段特定长度的唯一的Hash值，却不能通过这个Hash值重新获得目标信息。因此Hash算法常用在不可还原的密码存储、信息完整性校验等。
      * 优劣:
        * 消息摘要保证了消息的完整性。如果发送者发送的消息，在传输过程中被恶意篡改，那么接收者收到消息后，用同样的摘要算法计算其摘要，如果新摘要与发送者原始摘要不同，那么接收者就知道消息被篡改了。这里有一个前提条件就是：接收者一定要事先知道消息的原始摘要。消息摘要不需要秘钥，不存在秘钥的保管和分发问题。
      * 常见的消息摘要算法:MD2、MD4、MD5、HAVAL、SHA
    * 数字签名： 附加在数据单元上的一些数据,或是对数据单元所作的密码变换
      * 原理： 将原文通过特定HASH函数得到的摘要信息用发送者的私钥加密，与原文一起传送给接收者。接收者只有用发送者的公钥才能解密被加密的摘要信息。
      1. 示例：
        1. A和B之间通过非对称加密算法通信，B有A的公钥。
        2. A发送信息时用自己私钥加密，并且用hash算法对信息生成了摘要，再将该摘要用私钥加密，和信息一起发送给B
        3.  B收到信息后，用A的公钥解密看到了消息以及摘要，再用相同的hash算法对信息做摘要，对比收到的摘要即可判定信息是否被更改以及完整





---
### NOTE ATTRIBUTES
>Created Date: 2021-02-18 03:27:08
>Last Evernote Update Date: 2021-03-03 17:42:17
>author: 一的平方
>source: desktop.win
>source-url: https://blog.csdn.net/a724888/article/details/79180626
>source-application: yinxiang.win32
# 网络协议
1、TCP中常见的拥塞控制算法有哪些
  * 网络内尚未被确认收到的数据包数量 = 网络链路上能容纳的数据包数量 = 链路带宽 × 往返延迟
  * 什么是拥塞控制： TCP 维护一个拥塞窗口cwnd（congestion window），用来估计在一段时间内这条链路可以承载和运输的数据的数量，拥塞窗口的大小取决于网络的拥塞程度，并且动态地在变化
  * 拥塞控制的目标：最大化利用网络上瓶颈链路的带宽。
  * 什么是拥塞控制算法：但是为了达到最大的传输效率，我们该如何知道这条链路的运送效率是多少呢？
  * Linux 内核默认的 Reno
    * 慢启动：由小到大逐渐增加拥塞窗口的大小，在没有出现丢包时每收到一个 ACK 就将拥塞窗口大小加一（单位是 MSS，最大单个报文段长度），每轮次发送窗口增加一倍，呈指数增长，若出现丢包，则将拥塞窗口减半，进入拥塞避免阶段
    * 拥塞避免：窗口每轮次加一，呈线性增长；当收到对一个报文的三个重复的 ACK 时，认为这个报文的下一个报文丢失了，进入快重传阶段
    * 快重传和快恢复：在 TCP/IP 中，快速重传和恢复（fast retransmit and recovery，FRR）是一种拥塞控制算法，它能快速恢复丢失的数据包。没有 FRR，如果数据包丢失了，TCP 将会使用定时器来要求传输暂停。在暂停的这段时间内，没有新的或复制的数据包被发送。有了 FRR，如果接收机接收到一个不按顺序的数据段，它会立即给发送机发送一个重复确认。如果发送机接收到三个重复确认，它会假定确认件指出的数据段丢失了，并立即重传这些丢失的数据段。有了 FRR，就不会因为重传时要求的暂停被耽误。 当有单独的数据包丢失时，快速重传和恢复（FRR）能最有效地工作。当有多个数据信息包在某一段很短的时间内丢失时，它则不能很有效地工作。
  * Google BBR ：基于拥塞的拥塞控制算法




2、简述HTTPS的加密和认证过程
  * 数字证书：一种文件的名称，好比一个机构或人的签名，能够证明这个机构或人的真实性。
  * 加密和认证：加密是指通信双方为了防止敏感信息在信道上被第三方窃听，将明文加密成密文。认证是指通信双方为了确认对方是值得信任的消息发送方或接受方，而不是使用假身份的非法者，采取的确认身份的方式。只有同时进行加密和认证才能保证通信的安全，因此在SSL协议中这两者都被应用。早期使用对称加密，现在一般都是不对称加密，比方说RSA加密算法。
  * 消息摘要：消息摘要是把一段信息，通过某种算法，得出一段字符串，这个字符串就是消息的摘要。如果消息被篡改，那么摘要也一定会发生改变。其主要算法有MD5和SHA。在证书领域，一般都是SHA（安全哈希算法）。
  * 证书（certificate）：数字证书、加密和解密、消息摘要三者结合起来，就是在https中广泛应用的证书。证书本身携带了加密和解密的信息，并且可以标识自己的身份，也自带消息摘要。


认证：
  1. 客户端获取到了站点证书，拿到了站点的公钥
  2. 客户端找到其站点证书颁发者的信息
  3. 站点证书的颁发者验证服务端站点是否可信
  4. 往上回溯，找到根证书颁发者
  5. 通过根证书颁发者一步步验证站点证书颁布者是否可信


加密：
  1. 客户端请求服务器获取证书公钥
  2. 客户端(SSL/TLS)解析证书（无效会弹出警告）
  3. 生成随机值
  4. 用公钥加密随机值生成密钥
  5. 客户端将密钥发送给服务器
  6. 服务端用私钥解密密钥得到随机值
  7. 将信息和随机值混合在一起进行对称加密
  8. 将加密的内容发送给客户端
  9. 客户端用密钥解密信息




3、TCP 怎么保证可靠传输？
  1. 应用数据被分割成 TCP 认为最适合发送的数据块。TCP 给发送的每一个包进行编号，接收方对数据包进行排序，把有序数据传送给应用层。
  2. 数据校验： TCP 将保持它首部和数据的检验和。这是一个端到端的检验和，目的是检测数据在传输过程中的任何变化。如果收到段的检验和有差错，TCP 将丢弃这个报文段和不确认收到此报文段。
  3. 流量控制：TCP 连接的每一方都有固定大小的缓冲空间，TCP的接收端只允许发送端发送接收端缓冲区能接纳的数据。当接收方来不及处理发送方的数据，能提示发送方降低发送的速率，防止包丢失。TCP 使用的流量控制协议是可变大小的滑动窗口协议。 （TCP 利用滑动窗口实现流量控制）
  4. 拥塞控制：当网络拥塞时，减少数据的发送，（拥塞控制算法：慢启动、拥塞避免、快重传和快恢复）
  5. ARQ协议：基本原理就是每发完一个分组就停止发送，等待对方确认。在收到确认后再发下一个分组。ARQ包括停止等待ARQ协议和连续ARQ协议
  6. 超时重传：当 TCP 发出一个段后，它启动一个定时器，等待目的端确认收到这个报文段。如果不能及时收到一个确认，将重发这个报文段。
  7. 数据合理分片和排序：
    1. UDP：IP数据报大于1500字节,大于MTU.这个时候发送方IP层就需要分片(fragmentation).把数据报分成若干片,使每一片都小于MTU.而接收方IP层则需要进行数据报的重组.这样就会多做许多事情,而更严重的是,由于UDP的特性,当某一片数据传送中丢失时,接收方便无法重组数据报.将导致丢弃整个UDP数据报.
    2. TCP: 会按MTU合理分片，接收方会缓存未按序到达的数据，重新排序后再交给应用层。





  * MTU:最大传输单元
  * AQR自动重传协议：（Automatic Repeat-reQuest，ARQ）是OSI模型中数据链路层和传输层的错误纠正协议之一。它通过使用确认和超时这两个机制，在不可靠服务的基础上实现可靠的信息传输。如果发送方在发送后一段时间之内没有收到确认帧，它通常会重新发送。ARQ包括停止等待ARQ协议和连续ARQ协议。
    * 停止等待协议：
      * 停止等待协议是为了实现可靠传输的，它的基本原理就是每发完一个分组就停止发送，等待对方确认（回复ACK）。如果过了一段时间（超时时间后），还是没有收到 ACK 确认，说明没有发送成功，需要重新发送，直到收到确认后再发下一个分组
      * 在停止等待协议中，若接收方收到重复分组，就丢弃该分组，但同时还要发送确认；
      * 优点：简单
      * 缺点：信道占用率低，等待时间长
    * 连续ARQ协议:
      * 连续 ARQ 协议可提高信道利用率。发送方维持一个发送窗口，凡位于发送窗口内的分组可以连续发送出去，而不需要等待对方确认。接收方一般采用累计确认，对按序到达的最后一个分组发送确认，表明到这个分组为止的所有分组都已经正确收到了。
      * 优点：信道利用率高，容易实现。
      * 发送HTTP请求
      * 缺点：不能向发送方反映出接收方已经正确收到的所有分组的信息。 比如：发送方发送了 5条 消息，中间第三条丢失（3号），这时接收方只能对前两个发送确认。发送方无法知道后三个分组的下落，而只好把后三个全部重传一次。这也叫 Go-Back-N（回退 N），表示需要退回来重传已经发送过的 N 个消息。
    * 流量控制：TCP 利用滑动窗口实现流量控制。流量控制是为了控制发送方发送速率，保证接收方来得及接收。 接收方发送的确认报文中的窗口字段可以用来控制发送方窗口大小，从而影响发送方的发送速率。将窗口字段设置为 0，则发送方不能发送数据。
    *



4、从输入 URL 到展现页面的全过程


  1. URL输入
  2. DNS解析
  3. TCP连接
  4. 发送请求
  5. 服务器处理请求
  6. 服务器响应请求
  7. 浏览器解析渲染页面
  8. 连接结束




DNS解析：
  1. 网址到IP的过程
  2. 查找顺序： 浏览器缓存--> 操作系统缓存--> 本地host文件 --> 路由器缓存--> ISP DNS缓存 --> 顶级DNS服务器/根DNS服务器
  3. TCP连接： 拿到域名对应的IP地址之后，浏览器会以一个随机端口（1024<端口<65535）向服务器的WEB程序（常用的有httpd,nginx等）80端口发起TCP的连接请求，到达WEB程序，最终建立了TCP/IP的连接。
    1. 三次握手： ![noteattachment1][bd5f217251f3c98521c3dfc508c2d227]
    2. 为啥需要三次握手 :谢希仁著《计算机网络》中讲“三次握手”的目的是“为了防止已失效的连接请求报文段突然又传送到了服务端，因而产生错误
  4. 发送请求：
    1. 请求报文
      1. 请求行：请求方法、URL、协议版本
      2. 请求头：Host（表示主机名）/Connection,HTTP/1.1/ User-Agent 等等
      3. 请求体：可以承载多个请求参数的数据，包含回车符、换行符和请求数据，并不是所有请求都具有请求数据
  5. 服务器处理请求：nginx->WSGI->Django
  6. 服务器响应请求
    1. 响应报文
      1. 状态行
        1. 协议版本
        2. 状态码：
          * 1xx：指示信息–表示请求已接收，继续处理。
          * 2xx：成功–表示请求已被成功接收、理解、接受。
          * 3xx：重定向–要完成请求必须进行更进一步的操作。
          * 4xx：客户端错误–请求有语法错误或请求无法实现。
          * 5xx：服务器端错误–服务器未能实现合法的请求。
        3. 状态码描述
      2. 响应头(Response Header)
      3. 响应正文
  7. 浏览器渲染页面：
    1. 根据 HTML 解析出 DOM 树
    2. 根据 CSS 解析生成 CSS 规则树
    3. 结合 DOM 树和 CSS 规则树，生成渲染树
    4. 根据渲染树计算每一个节点的信息
    5. 根据计算好的信息绘制页面
  8. 断开连接 四次挥手 ![noteattachment2][8f5c3411331180d34888579a78c6d867]





5、简述常见的 HTTP 状态码的含义（301，304，401，403）
  * 1xx：指示信息–表示请求已接收，继续处理。
  * 2xx：成功–表示请求已被成功接收、理解、接受。
  * 3xx：重定向–要完成请求必须进行更进一步的操作。
  * 4xx：客户端错误–请求有语法错误或请求无法实现。
  * 5xx：服务器端错误–服务器未能实现合法的请求。




  1. 301 永久重定向 说明请求的资源已经被移动到了由 Location 头部指定的url上，是固定的不会再改变。搜索引擎会根据该响应修正
  2. 304 未改变说明无需再次传输请求的内容，也就是说可以使用缓存的内容。这通常是在一些安全的方法（safe），例如GET 或HEAD 或在请求中附带了头部信息： If-None-Match 或If-Modified-Since
  3. 401 Unauthorized 代表客户端错误，指的是由于缺乏目标资源要求的身份验证凭证，发送的请求未得到满足。
  4. 状态码 403 Forbidden 代表客户端错误，指的是服务器端有能力处理该请求，但是拒绝授权访问。这个状态类似于 401，但进入该状态后不能再继续进行验证。该访问是长期禁止的，并且与应用逻辑密切相关（例如不正确的密码）








6、HTTP 的方法有哪些？
  * GET
    * GET方法用于使用给定的URI从给定服务器中检索信息，即从指定资源中请求数据。使用GET方法的请求应该只是检索数据，并且不应对数据产生其他影响。在GET请求的URL中发送查询字符串mGET请求是可以缓存的，我们可以从浏览器历史记录中查找到GET请求，还可以把它收藏到书签中；且GET请求有长度限制，仅用于请求数据（不修改）。
    * tips：因GET请求的不安全性，在处理敏感数据时，绝不可以使用GET请求
  * POST
    * POST方法用于将数据发送到服务器以创建或更新资源，它要求服务器确认请求中包含的内容作为由URI区分的Web资源的另一个下属。POST请求永远不会被缓存，且对数据长度没有限制；我们无法从浏览器历史记录中查找到POST请求。
  * HEAD
    * HEAD方法与GET方法相同，但没有响应体，仅传输状态行和标题部分。这对于恢复相应头部编写的元数据非常有用，而无需传输整个内容。
  * PUT
    * PUT方法用于将数据发送到服务器以创建或更新资源，它可以用上传的内容替换目标资源中的所有当前内容。它会将包含的元素放在所提供的URI下，如果URI指示的是当前资源，则会被改变。如果URI未指示当前资源，则服务器可以使用该URI创建资源。
  * DELETE
    * DELETE方法用来删除指定的资源，它会删除URI给出的目标资源的所有当前内容。
  * CONNECT
    * CONNECT方法用来建立到给定URI标识的服务器的隧道；它通过简单的TCP / IP隧道更改请求连接，通常实使用解码的HTTP代理来进行SSL编码的通信（HTTPS）。
  * OPTIONS
    * OPTIONS方法用来描述了目标资源的通信选项，会返回服务器支持预定义URL的HTTP策略。
  * TRACE
    * TRACE方法用于沿着目标资源的路径执行消息环回测试；它回应收到的请求，以便客户可以看到中间服务器进行了哪些（假设任何）进度或增量。




方法| 说明| 支持的HTTP协议版本
---|---|---
GET| 获取资源| 1.0\1.1
POST| 传输实体主体| 1.0\1.1
PUT| 传输文件| 1.0\1.1
HEAD| 获得报文头部| 1.0\1.1
DELETE| 删除文件| 1.0\1.1
OPTIONS| 询问支持的方法| 1.1
TRACE| 追踪路径| 1.1
CONNECT| 要求用隧道协议链接代理| 1.1
LINK| 建立和资源之间的关系| 1.0
UNLINK| 断开连接关系| 1.0
7、HTTP 与 HTTPS 有哪些区别？
  * HTTP：是互联网上应用最为广泛的一种网络协议，是一个客户端和服务器端请求和应答的标准（TCP），用于从WWW服务器传输超文本到本地浏览器的传输协议，它可以使浏览器更加高效，使网络传输减少。
  * HTTPS：是以安全为目标的HTTP通道，简单讲是HTTP的安全版，即HTTP下加入SSL层，HTTPS的安全基础是SSL，因此加密的详细内容就需要SSL。




| HTTPS| HTTP
---|---|---
传输内容| 密文| 明文
使用协议| SSL| TCP
连接端口| 443| 80
身份验证| 有| 无
验证方式| CA验证| 无
建立连接| 12次握手（TCP3次，SSL9次）| 3次握手
HTTP缺点：
  1. 通信使用明文，内容可能会被窃听


  1. 不验证通信方的身份，因此有可能遭遇伪装
  2. 无法验证报文的完整性，所以有可能遭篡改




一句话总结：HTTP+加密+认证+完整性保护 = HTTPS


8、简述对称加密和非对称加密的概念
  * 对称加密：指加密和解密使用相同密钥的加密算法。


有时又叫传统密码算法，就是加密密钥能够从解密密钥中推算出来，同时解密密钥也可以从加密密钥中推算出来。而在大多数的对称算法中，加密密钥和解密密钥是相同的，所以也称这种加密算法为秘密密钥算法或单密钥算法。它要求发送方和接收方在安全通信之前，商定一个密钥。对称算法的安全性依赖于密钥，泄漏密钥就意味着任何人都可以对他们发送或接收的消息解密，所以密钥的保密性对通信性至关重要。
    * 特点：对称加密算法的特点是算法公开、计算量小、加密速度快、加密效率高。
    * 缺点：
      1. 交易双方都使用同样钥匙，安全性得不到保证。
      2. 每对用户每次使用对称加密算法时，都需要使用其他人不知道的惟一钥匙，这会使得发收信双方所拥有的钥匙数量呈几何级数增长， 密钥管理成为用户的负担。
      3. 密钥在传输过程中遭受中间人攻击可能会受通信不安全
      4. 对称加密算法一般不能提供信息完整性的鉴别。它无法验证发送者和接受者的身份；
    * 具体算法：DES算法，3DES算法，TDEA算法， Blowfish算法， RC5 算法，IDEA算法。
  * 非对称加密：非对称加密算法需要两个密钥: 公开密钥(publickey)和私有密钥(privatekey)。公开密钥与私有密钥是一对，如果用公开密钥对数据进行加密，只有用对应的私有密钥才能解密;如果用私有密钥对数据进行加密，那么只有用对应的公开密钥才能解密。因为加密和解密使用的是两个不同的密钥，所以这种算法叫作非对称加密算法。
    * 优劣：
      * 非对称加密使用了一对密钥，公钥与私钥，所以安全性高
      * 加密与解密速度慢。非对称加密的RSA加密效率较低，一次加密的数据大小也很局限
    * 过程：
      1.  A生成一对密钥，并将其中的一把作为公用密钥发送给B
      2. B得到该公钥，使用该公钥对机密信息进行加密后再发送给甲方，（其中也可以包含自己的公钥）
      3. A方收到后再用私钥对加密信息进行解密
    * 具体算法：RSA、Elgamal、背包算法、Rabin、HD,ECC（椭圆曲线加密算法）。


  * 消息摘要算法:Hash算法特别的地方在于它是一种单向算法，用户可以通过Hash算法对目标信息生成一段特定长度的唯一的Hash值，却不能通过这个Hash值重新获得目标信息。因此Hash算法常用在不可还原的密码存储、信息完整性校验等。
    * 优劣:
      * 消息摘要保证了消息的完整性。如果发送者发送的消息，在传输过程中被恶意篡改，那么接收者收到消息后，用同样的摘要算法计算其摘要，如果新摘要与发送者原始摘要不同，那么接收者就知道消息被篡改了。这里有一个前提条件就是：接收者一定要事先知道消息的原始摘要。消息摘要不需要秘钥，不存在秘钥的保管和分发问题。
    * 常见的消息摘要算法:MD2、MD4、MD5、HAVAL、SHA
  * 数字签名： 附加在数据单元上的一些数据,或是对数据单元所作的密码变换
    * 原理： 将原文通过特定HASH函数得到的摘要信息用发送者的私钥加密，与原文一起传送给接收者。接收者只有用发送者的公钥才能解密被加密的摘要信息。
    * 示例：
      1. A和B之间通过非对称加密算法通信，B有A的公钥。
      2. A发送信息时用自己私钥加密，并且用hash算法对信息生成了摘要，再将该摘要用私钥加密，和信息一起发送给B
      3.  B收到信息后，用A的公钥解密看到了消息以及摘要，再用相同的hash算法对信息做摘要，对比收到的摘要即可判定信息是否被更改以及完整


9、TCP的拥塞控制具体是怎么实现的？UDP有拥塞控制吗？
  * 具体通过 慢启动、拥塞控制、快重传和快恢复实现
    * 慢启动：
      1. 连接建好的开始先初始化 cwnd = 10，表明可以传 10 个 MSS 大小的数据。
      2. 每当收到一个 ACK，cwnd 加 1。这样每当过了一个 RTT，cwnd 翻倍，呈指数上升。
      3. 还有一个 ssthresh（slow start threshold），是一个上限。当 cwnd >=ssthresh 时，就会进入“拥塞避免算法”。
    * 拥塞窗口cwnd：TCP 维护一个拥塞窗口cwnd（congestion window），用来估计在一段时间内这条链路可以承载和运输的数据的数量，拥塞窗口的大小取决于网络的拥塞程度，并且动态地在变化
    * 传输轮次：一个传输轮次是指发送方把自己的发送窗口内的数据全部发送出去并收到对最后一个字节的确认。
    * RTT（Round Trip Time，环回时间）：一个数据包从发出去到回来的时间
    * 拥塞避免
      1. 每收到一个Ack，cwnd = cwnd + 1/cwnd，显然，cwnd > 1时无增长。
      2. 每经过一个RTT，cwnd++，线性增长（主要增长来源）。
      3. 慢启动算法主要呈指数增长，粗犷型，速度快（“慢”是相对于一步到位而言的）而拥塞避免算法主要呈线性增长，精细型，速度慢，但更容易在不导致拥塞的情况下，找到网络环境的cwnd最优值。
        * 慢开始门限： ssthresh
        * cwnd < ssthresh , 使用慢开始（慢启动）算法
        * cwnd = ssthresh , 使用慢开始算法或拥塞避免算法都可以
        * cwnd > ssthresh , 使用拥塞避免算法呢
    * 快重传:
      1. 超时重传。TCP认为这种情况太糟糕，调整力度比较大：
        1. ssthresh = cwnd /2
        2. cwnd = 1，重新进入慢启动过程（网络糟糕，要慢慢调整）
      2. 快速重传。TCP认为这种情况通常比RTO超时好一些，主流实现TCP Reno的调整力度更柔和（TCP Tahoe的实现和RTO超时一样暴躁）：
        1. 1\. ssthresh = cwnd /2
        2. 2\. cwnd = cwnd /2，进入快速恢复算法（网络没那么糟，可以快速调整，见下）
      3. 要求接收方在收到一个失序的报文段后就立即发出重复确认（为的是使发送方及早知道有报文段没有到达对方，可提高网络吞吐量约20%）而不要等到自己发送数据时捎带确认。
      4. 快重传算法规定，发送方只要一连收到三个重复确认就应当立即重传对方尚未收到的报文段，而不必继续等待设置的重传计时器时间到期。
    * 快恢复:
      * 如果触发了快速重传，即发送方收到至少3次相同的Ack，那么TCP认为网络情况不那么糟，也就没必要提心吊胆的，可以适当大胆的恢复
        1.  cwnd = ssthresh + 3 * MSS （尝试一步到位）
        2.  重传重复Ack对应的Seq
        3.  如果再收到该重复Ack，则cwnd++，线性增长（缓慢调整）
        4. 如果收到了新Ack，则cwnd = ssthresh ，然后就进入了拥塞避免的算法了
    *

  * 怎么判断是否为网络拥塞：如果发送方发现有Seq发送失败（表现为“丢包”），就认为网络拥塞了。
  * MSS，最大单个报文段长度
  * UDP没有拥塞控制


10、什么是跨域，什么情况下会发生跨域请求？
  * 同源：同源是指，域名，协议，端口均相同
  * 跨域：指与当前不同源的地址发送的请求，它允许浏览器向跨源服务器，发出XMLHttpRequest请求，从而克服了AJAX只能同源使用的限制。
  * 为什么需要跨域：浏览器会对上面提到的跨域请求作出限制。浏览器之所以要对跨域请求作出限制，是出于安全方面的考虑，因为跨域请求有可能被不法分子利用来发动 CSRF攻击。、
  * CORS需要浏览器和服务器同时支持
  * 浏览器将CORS请求分成两类：简单请求（simple request）和非简单请求（not-so-simple request）
    * 简单请求
      1. 请求方法是以下三种方法之一：
        * * HEAD
        * * GET
        * * POST
      2. HTTP的头信息不超出以下几种字段：
        * * Accept
        * * Accept-Language
        * * Content-Language
        * * Last-Event-ID
        * * Content-Type：只限于三个值application/x-www-form-urlencoded、multipart/form-data、text/plain、
      3.

    * 非简单请求外的即为非简单请求
      * 非简单请求是那种对服务器有特殊要求的请求，比如请求方法是PUT或DELETE，或者Content-Type字段的类型是application/json。
      * 非简单请求的CORS请求，会在正式通信之前，增加一次HTTP查询请求，称为"预检"请求（preflight）
  * CORS请求默认不发送Cookie和HTTP认证信息，如果要把Cookie发到服务器，一方面要服务器同意，指定Access-Control-Allow-Credentials字段
  * 如何实现跨域：
    * JSONP跨域
    * 代理服务器（nginx）
    * 协议跨域 (跨域资源访问CORS)


简单请求：
```
# 请求中多了 Origin
GET /cors HTTP/1.1
Origin: http://api.bob.com
Host: api.alice.com
Accept-Language: en-US
Connection: keep-alive
User-Agent: Mozilla/5.0...


# 服务器返回
Access-Control-Allow-Origin: http://api.bob.com
Access-Control-Allow-Credentials: true
Access-Control-Expose-Headers: FooBar
Content-Type: text/html; charset=utf-8


```


非简单请求的预检：
```
OPTIONS /cors HTTP/1.1
Origin: http://api.bob.com
Access-Control-Request-Method: PUT
Access-Control-Request-Headers: X-Custom-Header
Host: api.alice.com
Accept-Language: en-US
Connection: keep-alive
User-Agent: Mozilla/5.0...


# 预检请求的回应
HTTP/1.1 200 OK
Date: Mon, 01 Dec 2008 01:15:39 GMT
Server: Apache/2.0.61 (Unix)
Access-Control-Allow-Origin: http://api.bob.com
Access-Control-Allow-Methods: GET, POST, PUT
Access-Control-Allow-Headers: X-Custom-Header
Content-Type: text/html; charset=utf-8
Content-Encoding: gzip
Content-Length: 0
Keep-Alive: timeout=2, max=100
Connection: Keep-Alive
Content-Type: text/plain


```




11、简述 OSI 七层模型，TCP，IP 属于哪一层？
  1. 物理层（Physical Layer）在局部局域网上传送数据帧（Data Frame），它负责管理电脑通信设备和网络媒体之间的互通。包括了针脚、电压、线缆规范、集线器、中继器、网卡、主机接口卡等。
  2. 数据链路层（Data Link Layer）负责网络寻址、错误侦测和改错。当表头和表尾被加至数据包时，会形成信息框（Data Frame）。数据链表头（DLH）是包含了物理地址和错误侦测及改错的方法。数据链表尾（DLT）是一串指示数据包末端的字符串。例如以太网、无线局域网（Wi-Fi）和通用分组无线服务（GPRS）等。
  3. 网络层（Network Layer）决定数据的路径选择和转寄，将网络表头（NH）加至数据包，以形成报文。网络表头包含了网络资料。例如:互联网协议（IP）等。
  4. 传输层（Transport Layer）把传输表头（TH）加至数据以形成数据包。传输表头包含了所使用的协议等发送信息。例如:传输控制协议（TCP）等。
  5. 会话层（Session Layer）负责在数据传输中设置和维护计算机网络中两台计算机之间的通信连接。
  6. 表示层（Presentation Layer）把数据转换为能与接收者的系统格式兼容并适合传输的格式。
  7. 应用层（Application Layer）提供为应用软件而设计的接口，以设置与另一应用软件之间的通信。例如：HTTP、HTTPS、FTP、Telnet、SSH、SMTP、POP3等。




  * IP ：网络层
  * TCP：在传输层




12、简述 TCP 滑动窗口以及重传机制
重传机制：
  * 超时重传，在发送数据时，设定一个定时器，当超过指定的时间后，没有收到对方的 ACK 确认应答报文，就会重发该数据，也就是我们常说的超时重传
    * 什么情况下发生超时重传：
      1. 数据包丢失
      2. 确认应答丢失
    * 超时时间应该设置为多少呢：
      * 超时重传时间是以 RTO （Retransmission Timeout 超时重传时间）表示。
      * RTO应略于大 RTT；RTO过小，不必要的重传，会导致网络负荷增加；RTO过大，网络的空隙时间增大，降低了网络传输效率
      * RTT ：就是数据从网络一端传送到另一端所需的时间，也就是包的往返时间。
    * 如果超时重发的数据，再次超时的时候，又需要重传的时候，TCP 的策略是超时间隔加倍
      * 超时间隔加倍：每当遇到一次超时重传的时候，都会将下一次超时时间间隔设为先前值的两倍。两次超时，就说明网络环境差，不宜频繁反复发送
    * 缺点：超时周期可能相对较长。
  * 快速重传：它不以时间为驱动，而是以数据驱动重传
    * 快速重传的工作方式是当收到三个相同的 ACK 报文时，会在定时器过期之前，重传丢失的报文段。
    * 缺点：仍然不知道重传的时候，是重传之前的一个，还是重传所有的问题
  * SACK（ Selective Acknowledgment 选择性确认）
    * 在 TCP 头部「选项」字段里加一个 SACK 的东西，它可以将缓存的地图发送给发送方，知道了这些信息，就可以只重传丢失的数据。
  * D-SACK（Duplicate SACK）
    * 使用了 SACK 来告诉「发送方」有哪些数据被重复接收了




滑动窗口：
  * 窗口的实现实际上是操作系统开辟的一个缓存空间，发送方主机在等到确认应答返回之前，必须在缓冲区中保留已发送的数据。如果按期收到确认应答，此时数据就可以从缓存区清除
  * 窗口大小：指无需等待确认应答，而可以继续发送数据的最大值。
  * 累计应答/累计确认：
    * 1\. 为了保证顺序性，每一个包都有一个ID（序号），在建立连接的时候，会商定起始的ID是多少，然后按照ID一个个发送
    * 2\. 为了保证不丢包，对应发送的包都要进行应答，但不是一个个应答，而是会应答某个之前的ID，该模式称为累计应答
  * 窗口大小由哪一方决定？
    * 窗口的大小是由接收方的窗口大小来决定的
    * TCP 头里有一个字段叫 Window，也就是窗口大小
  * 发送方的滑动窗口
    * #1 已发送并收到 ACK确认的数据
    * #2 已发送但未收到 ACK确认的数据
    * #3 未发送但总大小在接收方处理范围内（接收方还有空间）
    * #4 是未发送但总大小超过接收方处理范围（接收方没有空间
  * 程序如何表示：通过四个指针，分别是
    * * SND.WND：表示发送窗口的大小（大小是由接收方指定的）；
    * * SND.UNA：是一个绝对指针，它指向的是已发送但未收到确认的第一个字节的序列号，也就是 #2 的第一个字节。
    * * SND.NXT：也是一个绝对指针，它指向未发送但可发送范围的第一个字节的序列号，也就是 #3 的第一个字节。
    * * 指向 #4 的第一个字节是个相对指针，它需要 SND.UNA 指针加上 SND.WND 大小的偏移量，就可以指向 #4 的第一个字节了。
    * 可用窗口大 = SND.WND -（SND.NXT - SND.UNA）
  * 接收方的滑动窗口
    * * #1 + #2 是已成功接收并确认的数据（等待应用进程读取）；
    * * #3 是未收到数据但可以接收的数据；
    * * #4 未收到数据并不可以接收的数据；
  * 使用两个指针进行划分:
    * * RCV.WND：表示接收窗口的大小，它会通告给发送方。
    * * RCV.NXT：是一个指针，它指向期望从发送方发送来的下一个数据字节的序列号，也就是 #3 的第一个字节。
    * * 指向 #4 的第一个字节是个相对指针，它需要 RCV.NXT 指针加上 RCV.WND 大小的偏移量，就可以指向 #4 的第一个字节了。
  * 接收窗口和发送窗口的大小是相等的吗？
    * 并不是完全相等，接收窗口的大小是约等于发送窗口的大小的。
    * 因为窗口大小随时变化，而TCP存在时间延迟


13、DNS 查询服务器的基本流程是什么？DNS 劫持是什么
  1. DNS：根据域名查出IP地址，工作在应用层
  2. 域名层级：


    1. 网站的域名排序是由低到高的
    * 例：www.example.com 真正域名是www.example.com.root (其中.root就是根域名)
    * 根域名的下一级叫做顶级域名，例如.com\\.net
    * 顶级域名的下一级叫做次级域名，这一级是用户可以注册的
    * 次级域名的下一级是主机名，又称三级域名。比如www
    * 主机名.次级域名.顶级域名.根域名 即host.sld.tld.root
  1. 基本流程
    1. 客户机提出域名解析请求，通过UDP协议发送给本地的域名服务器
    2. 本地域名服务器收到请求后，先查询本地缓存记录，如果有，直接返回
    3. 如果没有该记录，则本地域名服务器直接把请求发给根域名服务器，然后根域名服务器再返回给本地域名服务器一个所查询域 (根的子域) 的主域名服务器的地址
    4. 本地服务器再向上一步返回的域名服务器发送请求 , 然后接受请求的服务器查询自己的缓存 , 如果没有该纪录 , 则返回相关的下级的域名服务器的地址
    5. 重复步骤，直到找到正确的记录
    6. 本地域名服务器把返回结果保存到缓存，同时将结果返回给客户机
    7. （以上为迭代查询，递归查询则为根域名服务器代替客户机向下一级子 域发起请求查询，最后返回给客户机）
  2.

    1.  主机向本地域名服务器的查询一般都是采用 递归查询 ;
    2. 所谓递归查询就是 : 如果主机所询问的本地域名服务器不知道被查询的域名的 IP 地址 , 那么本地域名服务器就以 DNS 客户的身份 , 向其它根域名服务器继续发出查询请求报文 (即替主机继续查询) , 而不是让主机自己进行下一步查询 ; 因此 , 递归查询返回的查询结果或者是所要查询的 IP 地址 , 或者是报错 , 表示无法查询到所需的 IP 地址 ;
    3. 本地域名服务器向根域名服务器的查询的 迭代查询 ;
    4. 迭代查询的特点 : 当根域名服务器收到本地域名服务器发出的迭代查询请求报文时 , 要么给出所要查询的IP地址 , 要么告诉本地服务器 : "你下一步应当向哪一个域名服务器进行查询" ; 然后让本地服务器进行后续的查询 ; 根域名服务器通常是把自己知道的顶级域名服务器的 IP 地址告诉本地域名服务器 , 让本地域名服务器再向顶级域名服务器查询 ; 顶级域名服务器在收到本地域名服务器的查询请求后 , 要么给出所要查询的 IP 地址 , 要么告诉本地服务器下一步应当向哪一个权限域名服务器进行查询 ; 最后 , 知道了所要解析的 IP 地址或报错 , 然后把这个结果返回给发起查询的主机 ;
  3. DNS劫持：DNS劫持即通过某种技术手段，篡改正确域名和IP地址的映射关系，使得域名映射到了错误的IP地址，因此可以认为DNS劫持是一种DNS重定向攻击
    * 本地DNS劫持：客户端侧发生的DNS劫持统称为本地DNS劫持
    * DNS解析路径劫持：DNS解析过程中发生在客户端和DNS服务器网络通信时的DNS劫持统一归类为DNS解析路径劫持
      * DNS请求转发：通过技术手段(中间盒子，软件等)将DNS流量重定向到其他DNS服务器
      * DNS请求复制：利用分光等设备将DNS查询复制到网络设备，并先于正常应答返回DNS劫持的结果。
      * DNS请求代答：网络设备或者软件直接代替DNS服务器对DNS查询进行应答。
    * 篡改DNS权威记录 我们这里指的黑客非法入侵DNS权威记录管理账号，直接修改DNS记录的行为。


14、TCP四次挥手过程以及所处状态，为什么还需要有 time_wait
四次挥手过程：
![noteattachment2][8f5c3411331180d34888579a78c6d867]
  1. 当客户端没有待发送的数据时，它会向服务端发送 FIN 消息，发送消息后会进入 FIN_WAIT_1 状态；
  2. 服务端接收到客户端的 FIN 消息后，会进入 CLOSE_WAIT 状态并向客户端发送 ACK 消息，客户端接收到 ACK 消息时会进入 FIN_WAIT_2 状态；
  3. 当服务端没有待发送的数据时，服务端会向客户端发送 FIN 消息；
  4. 客户端接收到 FIN 消息后，会进入 TIME_WAIT 状态并向服务端发送 ACK 消息，服务端收到后会进入 CLOSED 状态；
  5. 客户端等待两个最大数据段生命周期（Maximum segment lifetime，MSL）2的时间后也会进入 CLOSED 状态；


  * MSL:数据段在网络中能够存活的最长时间
  * 为什么是2MSL: 网络中可能存在来自发起方的数据段，当这些发起方的数据段被服务端处理后又会向客户端发送响应，所以一来一回需要等待 2 倍的时间
  * 为什么需要time_wait


    1. 防止延迟的数据段被其他使用相同源地址、源端口、目的地址以及目的端口的 TCP 连接收到；因为数据段的网络传输时间不确定，所以可能会收到上一次 TCP 连接中未被收到的数据段；
    1. 保证 TCP 连接的远程被正确关闭，即等待被动关闭连接的一方收到 FIN 对应的 ACK 消息；因为客户端发出的 ACK 可能还没有被服务端接收，服务端可能还处于 LAST_ACK 状态，所以它会回复 RST 消息终止新连接的建立；




15、TCP 在什么情况下服务端会出现大量 CLOSE_WAIT ？
  1. 服务端接收到客户端的FIN后，并没有发送 FIN，导致服务端一直处于 CLOSE_WAIR 状态，无法最终进入 CLOSED 状态
  2. 连接没有正确释放
  3. 在递归中调用了连接，产生了死锁

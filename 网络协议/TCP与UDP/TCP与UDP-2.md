# TCP与UDP
TCP：是一种面向连接的、可靠的、基于字节流的传输层通信协议


* * *


  * 在一个 TCP 连接中，仅有两方进行彼此通信。广播和多播不能用于 TCP
  * TCP 使用校验和，确认和重传机制来保证可靠传输
  * TCP 给数据分节进行排序，并使用累积确认保证数据的顺序不变和非重复
  * TCP 使用滑动窗口机制来实现流量控制，通过动态改变窗口的大小进行拥塞控制




* * *


  * TCP 三次握手
    * 被动打开：由一端（服务器端）打开一个套接字（socket）然后监听来自另一方（客户端）的连接
      * 服务器执行了监听函数后，就在服务器上创建了两个队列
        * SYN队列：存放完成了二次握手的结果。 队列长度由listen函数的参数backlog指定。（也称为半连接队列）
        * ACCEPT队列：存放完成了三次握手的结果。队列长度由listen函数的参数backlog指定。（也成为全连接队列）
    * 三次握手过程：
      1. 客户端（通过执行connect函数）向服务器端发送一个SYN包，请求一个主动打开。该包携带客户端为这个连接请求而设定的随机数A作为消息序列号。
      2. 服务器端收到一个合法的SYN包后，把该包放入SYN队列中；回送一个SYN/ACK。ACK的确认码应为A+1，SYN/ACK包本身携带一个随机产生的序号B。
      3. 客户端收到SYN/ACK包后，发送一个Ack包，该包的序号被设定为A+1，而ACK的确认码则为B+1。然后客户端的connect函数成功返回。发送完毕后，客户端进入 ESTABLISHED 状态，当服务器端接收到这个包时，也进入 ESTABLISHED 状态，TCP 握手结束。
    * 问题一览：
      * 如果掉线：服务器端接到了客户端发的SYN后回了SYN-ACK后客户端掉线了，服务器端没有收到客户端回来的ACK，那么，这个连接处于一个中间状态，既没成功，也没失败。于是，服务器端如果在一定时间内没有收到的TCP会重发SYN-ACK。在Linux下，默认重试次数为5次，重试的间隔时间从1s开始每次都翻倍，5次的重试时间间隔为1s, 2s, 4s, 8s, 16s，总共31s
      * 如果发送的seq过期或者超时： 那么发送方就会直接发送 RST 控制消息中止这一次连接；
      * 三次握手中可以携带数据吗？：可以携带数据的。但是，第一次、第二次握手不可以携带数据，只能但三次。第一次不行是为了保护服务器不受攻击，第三次客户端已经是ESTABLISHED状态，所以可以。
      * 为什么需要三次握手：
        * 不采用三次握手，只要服务端发出确认，就建立新的连接了，此时客户端忽略服务端发来的确认，也不发送数据，则服务端一致等待客户端发送数据，浪费资源
        * 通过三次握手来确认双方的接受与发送能力是否正常
        * 如果是两次握手：如客户端发出连接请求，但因连接请求报文丢失而未收到确认，于是客户端再重传一次连接请求。后来收到了确认，建立了连接。数据传输完毕后，就释放了连接，客户端共发出了两个连接请求报文段，其中第一个丢失，第二个到达了服务端，但是第一个丢失的报文段只是在某些网络结点长时间滞留了，延误到连接释放以后的某个时间才到达服务端，此时服务端误认为客户端又发出一次新的连接请求，于是就向客户端发出确认报文段，同意建立连接
      * SYN攻击是什么：SYN攻击就是Client在短时间内伪造大量不存在的IP地址，并向Server不断地发送SYN包，Server则回复确认包，并等待Client确认，由于源地址不存在，因此Server需要不断重发直至超时，这些伪造的SYN包将长时间占用未连接队列，导致正常的SYN请求因为队列满而被丢弃，从而引起网络拥塞甚至系统瘫痪
        * 如何检测： netstat -n -p TCP | grep SYN_RECV
        * 如何防御：
          * 缩短超时（SYN Timeout）时间
          * 增加最大半连接数
          * 过滤网关防护
          * SYN cookies技术


![noteattachment1][bd5f217251f3c98521c3dfc508c2d227]


* * *


  * TCP四次挥手：
    * 四次挥手过程：
      * 第一次挥手(FIN=1，seq=x)
        * 假设客户端想要关闭连接，客户端发送一个 FIN 标志位置为1的包，表示自己已经没有数据可以发送了，但是仍然可以接受数据。发送完毕后，客户端进入 FIN_WAIT_1 状态。
      * 第二次挥手(ACK=1，ACKnum=x+1)
        * 服务器端确认客户端的 FIN 包，发送一个确认包，表明自己接受到了客户端关闭连接的请求，但还没有准备好关闭连接。发送完毕后，服务器端进入 CLOSE_WAIT 状态，客户端接收到这个确认包之后，进入 FIN_WAIT_2 状态，等待服务器端关闭连接。
      * 第三次挥手(FIN=1，seq=y)
        * 服务器端准备好关闭连接时，向客户端发送结束连接请求，FIN 置为1。发送完毕后，服务器端进入 LAST_ACK 状态，等待来自客户端的最后一个ACK。
      * 第四次挥手(ACK=1，ACKnum=y+1)
        * 客户端接收到来自服务器端的关闭请求，发送一个确认包，并进入 TIME_WAIT状态，等待可能出现的要求重传的 ACK 包。服务器端接收到这个确认包之后，关闭连接，进入 CLOSED 状态。客户端等待了某个固定时间（两个最大段生命周期，2MSL，2 Maximum Segment Lifetime）之后，没有收到服务器端的 ACK ，认为服务器端已经正常关闭连接，于是自己也关闭连接，进入 CLOSED 状态。
    * 问题一览：
      * 为什么挥手需要四次：关闭连接时，当服务端收到FIN报文时，很可能并不会立即关闭SOCKET，所以只能先回复一个ACK报文，告诉客户端，"你发的FIN报文我收到了"。只有等到我服务端所有的报文都发送完了，我才能发送FIN报文，因此不能一起发送。故需要四次挥手。
      * TIME_WAIT状态：
        * 确认服务端收到了FIN对应的ACK请求，以便能重传ACK请求，确保服务端能正确地关闭。
        * 防止延迟的数据段被其他使用相同源地址、源端口、目的地址以及目的端口的 TCP 连接收到
      * 为什么需要2MSL
        * MSL：静默数据段在网络中能够存活的最长时间
        * 网络中可能存在来自发起方的数据段，当这些发起方的数据段被服务端处理后又会向客户端发送响应。客户端在发送完最后一个ACK报文段后，再经过2MSL，就可以使本连接持续的时间内所产生的所有报文段都从网络中消失
      * TCP 在什么情况下服务端会出现大量 CLOSE_WAIT ？
        * 服务端接收到客户端的FIN后，并没有发送 FIN，导致服务端一直处于 CLOSE_WAIT 状态，无法最终进入 CLOSED 状态
        * 连接没有正确释放
        * 在递归中调用了连接，产生了死锁




![noteattachment2][8f5c3411331180d34888579a78c6d867]


* * *


  * TCP协议-如何保证传输可靠性
    * 校验和：检测到数据包在传输过程中是否发生了差错
      * 伪首部：
        * 伪首部共有12字节，包含如下信息：源IP地址、目的IP地址、保留字节(置0)、传输层协议号(TCP是6)、TCP报文长度(报头+数据)。
        * 伪首部是为了增加TCP校验和的检错能力：如检查TCP报文是否收错了(目的IP地址)、传输层协议是否选对了(传输层协议号)等
      * 校验和计算：
        * 发送方：首先将检验和置零，将伪首部、TCP报头、TCP数据分为16位的字节，反码相加法累加所有的16位字（进位也要累加）最后，对计算结果取反，作为TCP的校验和
        * 发送方：将所有原码 相加，高位叠加， 如全为1，则正确
      * 如果计算结果符合期望值，说明数据包没有收到干扰/损坏
      * 如果不符合期望，一般会直接丢弃该数据包
    * 序列号
      * TCP传输时将每个字节的数据都进行了编号，这就是序列号
      * 发送端和接收端各自独立维护一个seq, seq的初始值是在创建连接时初始化的（值是随机的）
      * 控制位SYN就是专门用来在发送方和接收方同步seq的 （这里的同步指的是让对方知道自己的seq初始值是多少）
      * 建立连接后的每一个报文都会携带seq
      * 作用：
        * 保证可靠性（当接收到的数据总少了某个序号的数据时，能马上知道）
        * 保证数据的按序到达
        * 提高效率，可实现多次发送，一次确认
        * 去除重复数据
    * 确认应答：
      * 当发送端的数据到达接收主机时，接收端主机会返回一个已收到消息的通知，这个消息叫做确认应答（ACK）
      * TCP的报文到达确认（ACK），是对接收到的数据的最高序列号的确认，并向发送端返回一个下次接收时期望的TCP数据包的序列号（Ack Number）
      * 例：机A发送的当前数据序号是400，数据长度是100，则接收端收到后会返回一个确认号是501的确认号给主机A
      * 如果发送端没有收到确认应答ACK，会进行数据重发，分两种情况
        * 发送端发送的数据丢包
        * 接收端发送的确认应答ACK丢包或延迟
      * 延迟确认：发送方可以直接发送多个报文， 接收方在接收到报文后先不急着响应ack，因为后续报文可能马上到达
      * 累计确认：因为延迟确认可以让我们同时对多个接受的报文进行一次确认，这个又称之为累计确认
      * 问题一览：
        * 每个seq都需要一个ack吗？
          * 不是，发送方可以直接发送多个报文， 接收方在接收到报文后先不急着响应ack，因为后续报文可能马上到达， 这就是ACK延迟确认。延迟确认可以让我们同时对多个接受的报文进行一次确认，这个又称之为累计确认
        * 如果同时发送多个seq报文，若中间某一个丢包，ack如何响应呢？
          * 例：发送方发送了seq=1,seq=2,seq=3的报文， seq=2丢包， 但是接收方缓存了1和3，所以知道这部分报文不连续，中间缺少2，所以响应了一个ack=2 (一般叫做最小ack)，发送方重发seq=2的报文， 接收方发现1,2,3已经完整接收了，就响应下一个期望值, 即响应ack=4
    * 超时重传:当报文发出后在一定的时间内未收到接收方的确认，发送方就会进行重传（通常是在发出报文段后设定一个闹钟，到点了还没有收到应答则进行重传）。
      * 分两种情况
        * 发送端发送的数据丢包
        * 接收端发送的确认应答ACK丢包或延迟
        * 如果是第一个原因，接收方收到二次重发的数据后，便进行ACK应答。如果是第二个原因，接收方发现接收的数据已存在（判断存在的根据就是序列号，所以上面说序列号还有去除重复数据的作用），那么直接丢弃，仍旧发送ACK应答。
      * 重传时间: 重传超时时间（Retransmission TimeOut）， 一般简称RTO，将这个往返时间和偏差时间相加，RTO就是比这个总和要稍大一点的值
      * 往返时延 RTT （Round Trip Time）是配置RTO的一个重要指标， 但是由于网络间端到端的RTT并不是固定的，所以TCP采用了一种自适应的方法来计算RTT， 并且根据计算的值来配置RTO
      * 问题一览：
        * 每发送一个报文就启动一个定时器吗？
          * 为了保证可靠性，TCP增加了超时重传机制， 使得每个未被确认（ACK）的报文在一定时间后可以被重新发送，一种实现方式就为每个未被确认的报文都单独配置一个计时器，可是这样做的话开销太大了，在RFC 6298 的Managing the RTO Timer中提及了一种单一计时器的管理方式
          * 每个已发送但未确认数据包都会被放进队列里， 这个队列持有一个单独的计时器，当第一个数据包进入队列时，计时器启动了，如果计时器超时，队列头部的数据包会被重发，并且计时器重新计时，当收到ACK时，计时器也会重启，队列的所有数据都被确认了的话，就关闭定时器
        * 超时时间怎么设置呢？
          * 往返时延 RTT （Round Trip Time）是配置RTO的一个重要指标， 但是由于网络间端到端的RTT并不是固定的，所以TCP采用了一种自适应的方法来计算RTT， 并且根据计算的值来配置RTO，整个过程是动态的，也就是说当RTT变化时，RTO也能相应的做出调整
        * 一定要超时了才重传吗？
          * TCP有一个快速重传机制， 当一个接收方收到三个以上的重复ack时，接收方就会直接根据ack的值重传对应的报文而无需等待超时
    * 连接管理：TCP是面向连接的通信协议，面向连接是指在数据通信之前先做好通信两端之间的准备工作
      * 三次握手
      * 四次挥手
    * 流量控制
      * 滑动窗口：
        * TCP 引入了窗口这个概念。确认应答不是以每个分段来确认，而是以更大的单位进行确认，转发时间将会被大幅地缩短。也就是说，发送端主机，在发送了一个段以后不必要一直等待确认应答，而是继续发送
        * 窗口大小就是指无需等待确认应答ACK而继续发送数据的最大值
        * 窗口的实现实际上是操作系统开辟的一个缓存空间，发送方主机在等到确认应答返回之前，必须在缓冲区中保留已发送的数据。如果按期收到确认应答，此时数据就可以从缓存区清除
        * 窗口大小：指无需等待确认应答，而可以继续发送数据的最大值。
        * 滑动窗口特点：
          * 窗口内的数据即便没有收到确认应答也可以被发送出去。不过，在整个窗口的确认应答没有到达之前，如果其中部分数据出现丢包，那么发送端仍然要负责重传。为此，发送端主机需要设置缓存保留这些待被重传的数据，直到收到他们的确认应答。
          * 在滑动窗口以外的部分包括未发送的数据以及已经确认对端已收到的数据。当数据发出后若如期收到确认应答就可以不用再进行重发，此时数据就可以从缓存区清除。
          * 收到确认应答的情况下，将窗口滑动到确认应答中的序列号的位置。这样可以顺序地将多个段同时发送提高通信性能。这种机制也别称为滑动窗口控制。
        * 累计应答/累计确认：
          * 1\. 为了保证顺序性，每一个包都有一个ID（序号），在建立连接的时候，会商定起始的ID是多少，然后按照ID一个个发送
          * 2\. 为了保证不丢包，对应发送的包都要进行应答，但不是一个个应答，而是会应答某个之前的ID，该模式称为累计应答
        * 窗口大小由哪一方决定？
          * 窗口的大小是由接收方的窗口大小来决定的
          * TCP 头里有一个字段叫 Window，也就是窗口大小
      * 发送方的滑动窗口
        * #1 已发送并收到 ACK确认的数据
        * #2 已发送但未收到 ACK确认的数据
        * #3 未发送但总大小在接收方处理范围内（接收方还有空间）
        * #4 是未发送但总大小超过接收方处理范围（接收方没有空间
      * 接收方的滑动窗口
        * * #1 + #2 是已成功接收并确认的数据（等待应用进程读取）；
        * * #3 是未收到数据但可以接收的数据；
        * * #4 未收到数据并不可以接收的数据；
      * 使用两个指针进行划分:
        * * RCV.WND：表示接收窗口的大小，它会通告给发送方。
        * * RCV.NXT：是一个指针，它指向期望从发送方发送来的下一个数据字节的序列号，也就是 #3 的第一个字节。
        * * 指向 #4 的第一个字节是个相对指针，它需要 RCV.NXT 指针加上 RCV.WND 大小的偏移量，就可以指向 #4 的第一个字节了。
      * 问题一览：
        * 接收窗口和发送窗口的大小是相等的吗？
          * 并不是完全相等，接收窗口的大小是约等于发送窗口的大小的。
          * 因为窗口大小随时变化，而TCP存在时间延迟
        * 丢包了怎么办：
          * .确认应答ACK未能正确返回的情况 。在这种情况下，数据是已经被对端主机成功接收了的，是不需要进行重新发送的。 然而，如果在没有使用窗口控制的前提下，没有收到确认应答包的数据包都会被重发。 但是，在使用了窗口控制以后，就如下图所示，某些应答包即使丢失了也无需重发，这也提高了传输效率。（只要ACK正常返回了，说明前面序列号的数据都正常读取了，那么即使中间的ACK丢失也不需要进行数据重发！）
          * 某个报文丢失的情况 如果当接收端主机接收到一个自己应该接收的序列号之外的数据包时，它会一直对当前接收到的数据包返回确认应答包。发送端主机如果 连续 3 次 接收到同一个确认应答包，就会将其对应的数据重发，这种机制比之前提到的“超时重发”更加高效，所以被称之为“快速重传”
    * 拥塞控制
      * TCP引入慢启动机制，先发出少量数据，就像探路一样，先摸清当前的网络拥堵状态后，再决定按照多大的速度传送数据，以此实现拥塞控制
      * 具体通过 慢启动、拥塞控制、快重传和快恢复实现
        * 慢启动：
          1. 连接建好的开始先初始化 cwnd = 10，表明可以传 10 个 MSS 大小的数据。
          2. 每当收到一个 ACK，cwnd 加 1。这样每当过了一个 RTT，cwnd 翻倍，呈指数上升。
          3. 还有一个 ssthresh（slow start threshold），是一个上限。当 cwnd >=ssthresh 时，就会进入“拥塞避免算法”。
        * 拥塞窗口cwnd：TCP 维护一个拥塞窗口cwnd（congestion window），用来估计在一段时间内这条链路可以承载和运输的数据的数量，拥塞窗口的大小取决于网络的拥塞程度，并且动态地在变化
        * 传输轮次：一个传输轮次是指发送方把自己的发送窗口内的数据全部发送出去并收到对最后一个字节的确认。
        * RTT（Round Trip Time，环回时间）：一个数据包从发出去到回来的时间
        * 拥塞避免
          1. 每收到一个Ack，cwnd = cwnd + 1/cwnd，显然，cwnd > 1时无增长。
          2. 每经过一个RTT，cwnd++，线性增长（主要增长来源）。
          3. 慢启动算法主要呈指数增长，粗犷型，速度快（“慢”是相对于一步到位而言的）而拥塞避免算法主要呈线性增长，精细型，速度慢，但更容易在不导致拥塞的情况下，找到网络环境的cwnd最优值。
            * 慢开始门限： ssthresh
            * cwnd < ssthresh , 使用慢开始（慢启动）算法
            * cwnd = ssthresh , 使用慢开始算法或拥塞避免算法都可以
            * cwnd > ssthresh , 使用拥塞避免算法呢
        * 快重传:
          1. 超时重传。TCP认为这种情况太糟糕，调整力度比较大：
            1. ssthresh = cwnd /2
            2. cwnd = 1，重新进入慢启动过程（网络糟糕，要慢慢调整）
          2. 快速重传。TCP认为这种情况通常比RTO超时好一些，主流实现TCP Reno的调整力度更柔和（TCP Tahoe的实现和RTO超时一样暴躁）：
            1.  ssthresh = cwnd /2
            2.  cwnd = cwnd /2，进入快速恢复算法（网络没那么糟，可以快速调整，见下）
          3. 要求接收方在收到一个失序的报文段后就立即发出重复确认（为的是使发送方及早知道有报文段没有到达对方，可提高网络吞吐量约20%）而不要等到自己发送数据时捎带确认。
          4. 快重传算法规定，发送方只要一连收到三个重复确认就应当立即重传对方尚未收到的报文段，而不必继续等待设置的重传计时器时间到期。
        * 快恢复:
          * 如果触发了快速重传，即发送方收到至少3次相同的Ack，那么TCP认为网络情况不那么糟，也就没必要提心吊胆的，可以适当大胆的恢复
            1.  cwnd = ssthresh + 3 * MSS （尝试一步到位）
            2.  重传重复Ack对应的Seq
            3.  如果再收到该重复Ack，则cwnd++，线性增长（缓慢调整）
            4. 如果收到了新Ack，则cwnd = ssthresh ，然后就进入了拥塞避免的算法了
      * 怎么判断是否为网络拥塞：如果发送方发现有Seq发送失败（表现为“丢包”），就认为网络拥塞了。
      * MSS，最大单个报文段长度
      * UDP没有拥塞控制










* * *




  * UDP
  * UDP 是一个简单的传输层协议。和 TCP 相比，UDP 有下面几个显著特性：
    * UDP 缺乏可靠性。UDP 本身不提供确认，序列号，超时重传等机制。UDP 数据报可能在网络中被复制，被重新排序。即 UDP 不保证数据报会到达其最终目的地，也不保证各个数据报的先后顺序，也不保证每个数据报只到达一次
    * UDP 数据报是有长度的。每个 UDP 数据报都有长度，如果一个数据报正确地到达目的地，那么该数据报的长度将随数据一起传递给接收方。而 TCP 是一个字节流协议，没有任何（协议上的）记录边界。
    * UDP 是无连接的。UDP 客户和服务器之前不必存在长期的关系。UDP 发送数据报之前也不需要经过握手创建连接的过程。
    * UDP 支持多播和广播。




  * UDP 协议头：UDP 协议头中只包含 4 个字段，分别是源端口、目的端口、长度和校验码，其中每一个字段都占 16 比特，即 2 字节，这 4 个字段的作用如下：
    * 源端口是一个可选字段，它表示发送方进程的端口号，接收方可以使用该字段（不一定准确）向发送方发送信息；
    * 目的端口是数据报接收方的端口号，它只在目标的 IP 地址下才有意义；
    * 长度是协议头和数据报中数据长度的总和，表示整个数据报的大小
    * 校验码使用 IP 首部、UDP 首部和数据报中的数据进行计算3，接收方可以通过校验码验证数据的准确性，发现传输过程中出现的问题
  * TCP与UDP的区别：
    * UDP没有三次握手、四次挥手（TCP面向连接（如打电话要先拨号建立连接）;UDP是无连接的，即发送数据之前不需要建立连接）
    * UDP没有拥塞控制
    * UDP没有重传策略
    * UDP没有流量控制
    * TCP面向字节流，实际上是TCP把数据看成一连串无结构的字节流;UDP是面向报文的
    * 每一条TCP连接只能是点到点的;UDP支持一对一，一对多，多对一和多对多的交互通信
    * TCP首部开销20字节;UDP的首部开销小，只有8个字节
    * TCP的逻辑通信信道是全双工的可靠信道，UDP则是不可靠信道
  * 问题一览：
    * 为什么DNS使用UDP协议
      * UDP 协议
        * DNS 查询的数据包较小、机制简单；
        * UDP 协议的额外开销小、有着更好的性能表现；
      * TCP 协议
        * DNS 查询由于 DNSSEC 和 IPv6 的引入迅速膨胀，导致 DNS 响应经常超过 MTU 造成数据的分片和丢失，我们需要依靠更加可靠的 TCP 协议完成数据的传输；
        * 随着 DNS 查询中包含的数据不断增加，TCP 协议头以及三次握手带来的额外开销比例逐渐降低，不再是占据总传输数据大小的主要部分；




等效的 OSI 层
|
TCP/IP 层
|
TCP/IP 协议示例
---|---|---
应用、会话、表示
|
应用
|
NFS、NIS、DNS、LDAP、telnet、ftp、rlogin、rsh、rcp、RIP、RDISC、SNMP 等
传输
|
传输
|
TCP、UDP、SCTP
网络
|
Internet
|
IPv4、IPv6、ARP、ICMP
数据链路
|
数据链路
|
PPP、IEEE 802.2
物理
|
物理网络
|
以太网 (IEEE 802.3)、令牌环、RS-232、FDDI 等等







---
### ATTACHMENTS
[bd5f217251f3c98521c3dfc508c2d227]: media/2021-02-18_03-26-57-2.jpg
[2021-02-18_03-26-57-2.jpg](media/2021-02-18_03-26-57-2.jpg)
>hash: bd5f217251f3c98521c3dfc508c2d227
>source-url: file://C:\Users\610-04\AppData\Local\Temp\三次握手.jpg
>file-name: 三次握手.jpg

[8f5c3411331180d34888579a78c6d867]: media/2021-02-18_03-26-57-2.png
[2021-02-18_03-26-57-2.png](media/2021-02-18_03-26-57-2.png)
>hash: 8f5c3411331180d34888579a78c6d867
>source-url: file://C:\Users\610-04\AppData\Local\Temp\四次挥手.png
>file-name: 四次挥手.png

---
### NOTE ATTRIBUTES
>Created Date: 2021-02-18 03:26:57
>Last Evernote Update Date: 2021-02-25 17:43:42
>author: 一的平方
>source: desktop.win
>source-url: https://www.jianshu.com/p/42dbcd39c3e7
>source-application: yinxiang.win32